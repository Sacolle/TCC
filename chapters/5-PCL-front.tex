% 5. PCL front
\chapter{PCL-front}

O fim do projeto é utilizar a linguagem $PCL_{back}$ como um meio de prova para estratégias de solução de memória. Para demonstrar essa capacidade, como elaborado em \ref{chap4}, desenvolveu-se a linguagem de \emph{front-end}, $PCL_{front}$, que implementa um sistema de \emph{Borrow Checker} e é definido via compilação para $PCL_{back}$.

O design de $PCL_{front}$ partiu do formato de $PCL_{back}$, focando em gerar o menor número de modificações sintáticas para que a compilação fosse simples de se definir. Duas decisões foram tomadas que alteraram o funcionamento do \emph{Borrow Checker} de $PCL_{back}$ comparado com o de Rust, a fim de manter a simplicidade da linguagem. \textbf{1}: Ao invés de se utilizar um sistema de Rust que evoca tipos lineares, decidiu-se usá-los propriamente, voltando a alocações e desalocações manuais, regidas pela regra do uso exatamente uma vez. Na linguagem, o tipo $\text{*}\tau$ é linear enquanto os demais são não lineares. Isso simplificada a compilação por evitar as chamadas implícitas de liberação de memória que existem em Rust, mas ainda modela o comportamento deste, com liberações sendo necessárias no fim de escopos para que um programa seja bem tipado. \textbf{2}: Sem paralelismo, há menos necessidade de utilizar a regra de apenas um empréstimo mutável ou, exclusivamente, vários empréstimos imutáveis. Assim, $PCL_{front}$ permite várias referências mutáveis, chamadas \emph{alias} ($@\tau'a$) no sistema de tipos. \todo{A decisão de multiplos alias evoca o sistema de lineridade de Cyclone.}

O objetivo dessa linguagem é, quando compilada para $PCL_{back}$, nunca atingir uma derivação de $\KW{panic}\;\KW{UseAfterFree}$. As demais falhas temporais são permitidas na atual configuração do programa. Ao se aproximar mais do sistema de linearidade de Rust, movendo-se para um sistema de liberação automática de memória, pode-se começar a validar as demais falhas de memória temporais.

% 	5.1 Syntax
\section{Sintaxe}

A sintaxe da linguagem é bem próxima de um $PCL_{back}$ tipado. O modelo de linearidade necessitou de alguns operadores adicionais sendo eles a troca $:=:$ e troca que dereferência $:=:\!\text{*}$; o incremento $+=$ e decremento $-=$; e a cópia de ponteiro $\KW{alias}$ e a cópia de ponteiro que dereferência $\KW{alias}\!\text{*}$. Os termos $\KW{new}\typearg{\tau}$ e $\KW{delete}$ substituem o $\KW{malloc}$ e $\KW{free}$ com a mesma funcionalidade, mas com nomes que indicam uma operação mais alto nível. Por fim, os \emph{macros} \emph{PANIC} e \emph{NULL} se tornaram as expressões $\KW{stop}$ e $\KW{nullptr}\typearg{\tau}$ respectivamente. Tem-se também $\KW{nullalias}\typearg{\tau}$ como o \emph{alias} nulo da linguagem. A sintaxe é descrita por \ref{fig:pcl-front:sintax}.

\begin{figure}[ht]
	\caption{Sintaxe de $PCL_{front}$}
	\label{fig:pcl-front:sintax}
	\begin{align*}
		Types \ni \tau ::&= \KW{int} \OR \text{*}\tau \OR @\tau'a \OR (\bar\tau) \to \tau \\
		Locals \ni l ::&= l^m \OR l^p &&\\ 
		Value \ni v ::&= n \OR l && \\
		BinOp \ni op ::&= + | - | * | < | > | = | \land | \lor \\
		Expression \ni e ::&= x \OR v \\
		&\NLOR e\; op\; e \OR !e  \\
		&\NLOR \text{*}e \OR \&x \OR \KW{alias} \; x \OR \KW{alias}\text{*} \; x\\
		&\NLOR e;e \OR \{e\} \\ 
		&\NLOR \KW{new}\typearg\tau(e) \OR \KW{delete}(e, e) \; \\ 
		&\NLOR \KW{var}\; x: \tau := e \OR e_1 := e_2 \\
		&\NLOR e_1 :=: e_2 \OR e_1 :=:\!\text{*}\;e_2\\
		&\NLOR \KW{if}(e) \; e \; \KW{else} \; e\\
		&\NLOR f(\bar e) \\ 
		&\NLOR \KW{stop}\\ 
		&\NLOR \KW{nullprt}\typearg{\tau} \OR \KW{nullalias}\typearg{\tau}\\ 
		Function \ni F ::&= \KW{fn} \; f(\overline{x : \tau}) \to \tau \; e \; F \; | \; \mathbf{let}\;() \; e \\
	\end{align*}
	\legend{Fonte: Os Autores.}
\end{figure}

\noindent$'a$, $x$ e $f$ são meta variáveis que cobrem as regiões, nomes de variáveis e nomes de funções de um programa respectivamente. Os nomes de variáveis $x$ também são usados como o nome dos empréstimos, visto que nesta versão do \emph{Borrow Checker}, não se precisa anotar o modo de acesso, todos os acessos são mutáveis.
 
Há algumas omissões importantes. Não há tipos tupla ou recursivos. Mesmo que $PCL_{back}$ pudesse representar eles, eles complicam o \emph{Borrow Checker} e o passo de compilação. Entretanto, a omissão é principalmente por limite de tempo e escopo do projeto. Essa é a mesma razão pela omissão do operador $\KW{while}$ e declarações globais.

% 	5.3 Checagem de Tipos
\section{Checagem de Tipos e Regiões}

\todo[inline]{É aqui que tu comenta da forma do borrow checker, assim como as regras de aliasing e acesso a tipos lineares. }

% One important aspect of $PCL_{front}$'s linear type system is how to deal with pointer
% dereferences. Following Cyclone's rules for accessing linear pointers\cite{CYCLONEMEM},
% a pointer $\text{*}\tau$ or $@\tau'a$ can be safely dereferenced if $\tau$ is nonlinear.
% For other cases a swap and alias attached with a dereference are safe abstractions 
% ($\mathbf{alias}\text{*}\;e$, $e_1 :=:\!\!\text{*} \;e_2$).

% The borrow checker implemented is based on the Polonius 
% proposal\cite{Matsakis_2018, Stjerna1684081}. This implementation requires that 
% a node in the derivation tree alter a state which will be used for the sequent 
% assessment of other nodes. This imposes an evaluation order of depth first, 
% which is shown in the notation by each assessment returning its computed type 
% and its resulting environments. 

% These environments are: $\Gamma$, the association between names and types; 
% $U$, similar to $\Gamma$, but as an intermediary space between used value and 
% restored value; $R$ is a set of region pairs $('a, 'b)$, such as 
% $'a : 'b$ ($a$ outlives $b$), $R$ is transitive; $L$ is a set of region to 
% loan relations, which propagates over $R$ in that 
% $('a,'b) \in R \land ('a, x) \in L\to ('b, x) \in L$. Any access to an alias
% $@\tau'a$ needs to validate that $'a$ has a valid loan, as in (\textsc{DerefAlias}). 


%   5.4 Definição via compilação
\section{Definição via Compilação}