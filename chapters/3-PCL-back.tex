% 3. PCL back
\chapter{PCL-back}

% This work introduces $PCL_{back}$, a C-like core language de-
% signed to detect memory safety violations and to classify
% them. It is designed to be simple, for ease of developing
% proofs, but expressive enough to express common memory
% errors in C. Its syntax is defined as such:

Tendo em vista as falhas de memória descritas na seção \ref{sec:mem-error}, e visando analisá-las mais profundamente, é necessário desenvolver uma linguagem alvo para o fim de prova via compilação. A meta desse projeto é ter uma base relativamente agnóstica a solução a ser provada. Assim, introduz-se $PCL_{back}$, uma linguagem núcleo similar a C desenvolvida para detectar violações de segurança de memória e classificá-las. Ela é definida por sintaxe e semântica operacional \emph{small-step}. 

A escolha de C como base serviu para englobar todos as falhas de memórias, visto que C é uma linguagem que permite acesso e manipulação (quase) irrestrita à memória. Ou seja, pode-se expressar todas as falhas na seção \ref{sec:mem-error}. Essa é uma razão bem circular, as falhas são comuns em C porque este permite acesso brando a memória e assim elas são descritas; a linguagem que melhor reproduz elas é C, pois tem acesso \emph{laissez-faire} a memória.


%	3.1 Syntax
\section{Sintaxe}

A sintaxe baseada em C também se demonstrou familiar e facilitou a compreensão dos problemas e exemplos. Adicionalmente, esta é uma linguagem de expressões, permitindo certos padrões funcionais. Mesmo destoando de C, essa característica emergiu acidentalmente da implementação de funções na linguagem. A  sintaxe é definida em \ref{fig:pclback:sintax}.
\todo{Adicionar linebreak para fazer o split de das regras em várias páginas?}
\begin{figure*}[ht]
	\begingroup
	%\setlength{\jot}{-0.2ex} 
		\begin{align*}
			Locals \ni l ::&= l^m \OR l^p &&\\ 
			Value \ni v ::&= n \OR l && \\
			BinOp \ni op ::&= + | - | * | < | > | = | \land | \lor \\
			Expression \ni e ::&= x \OR v \\
			&\NLOR e\; op\; e \OR !e  \\
			&\NLOR \text{*}e \OR \&x \\
			&\NLOR e;e \; \OR \{\,e\,\} \OR \KW{pop}\;e\; \\ 
			&\NLOR \mathbf{malloc}(e) \OR \mathbf{free}(e, e) \; \\ 
			&\NLOR \mathbf{let}\; x[n] \OR e := e \; \\
			&\NLOR \mathbf{if}(e) \; e \; \mathbf{else} \; e \; \OR \mathbf{while}(e) \; e \\
			&\NLOR f(\bar e) \OR \KW{Fpop}\;e\\ 
			&\NLOR \mathbf{panic}\;pcode \\ 
			PanicCodes \ni pcode ::&= \mathbf{OutOfBoundsRead}\\
			&\NLOR \mathbf{OutOfBoundsWrite}\\
			&\NLOR \mathbf{NullPtrDereference}\\
			&\NLOR \mathbf{UserError}\\
			&\NLOR \mathbf{UseAfterFree}\\
			&\NLOR \mathbf{UninitializedAcess}\\
			&\NLOR \mathbf{FreeMemoryNotOnHeap}\\
			&\NLOR \mathbf{PartialFree}\\
			&\NLOR \mathbf{DoubleFree}\\
			Function \ni F ::&= \mathbf{let} \; f(\overline{x})\; e \; F \; | \; \mathbf{let}\;() \; e \\
			Globals \ni G ::&= \mathbf{global}\; x[n] \;G \;|\; F
		\end{align*}
	\endgroup
	\caption{Sintaxe de $PCL_{back}$}
	\label{fig:pclback:sintax}
\end{figure*}
% NOTE: funciona, yeyyyyyy
\FloatBarrier

Nela, o termo $x$ cobre todos os possíveis nomes de variáveis em um programa. 
$f$ cobre todos os nomes de funções. O conjunto $PanicCodes$ são so tipos de falhas de memória, que podem ser divididos nas 5 classes (mais extras) da seguinte forma:
\begin{enumerate}
	\item $\mathbf{OutofBoundsRead}$ e $\mathbf{OutofBoundsWrite}$ são falhas espaciais (\ref{sec:mem-error:spacial}), sendo leitura e escrita para além dos limites do \emph{buffer} respectivamente.
	\item $\mathbf{UseAfterFree}$, $\mathbf{FreeMemoryNotOnHeap}$, $\mathbf{Partial ree}$ e $\mathbf{Double Free}$ são falhas temporais (\ref{sec:mem-error:temporal}), sendo uso de uma região liberada de memória para o primeiro e corrupção da estrutura alocadora por diversos meios para os demais.
	\item $\mathbf{UninitializedAccess}$ é uma falha de inicialização (\ref{sec:mem-error:init}), sendo o acesso ao valor alocado, mas não inicializado. 
	\item $\mathbf{NullPtrDereference}$ é uma falha específica ao domínio de C, em que essa linguagem se baseia (\ref{sec:mem-error:temporal:null}), sendo o acesso ao ponteiro nulo.
	\item $\mathbf{UserError}$ é uma interrupção manual de usuário, similar a \lstinline[language=C]|exit(1)| em C. É usado como mecanismo de emissão de erros controlados que terminam a execução.
\end{enumerate}

\noindent Acima há a omissão das falhas de tipos, pois $PCL_{back}$ não é tipado. Os seus valores, locais $l$ e números $n$, encaixam, independente do tamanho, em uma célula. Há também omissão das falhas de condição de corrida. Elas não são representáveis nessa linguagem, pois não possui mecanismos de paralelização.

Esses códigos de pânico $pcode$ servem como interrupções na avaliação da linguagem, indicando uma falha de memória. Eles são um importante componente no processo de compilação e prova. Um método de segurança de memória não precisa ser compreensivo e cobrir todas as falhas geradas, mas se a sua compilação para $PCL_{back}$ não gerar o conjunto de $PanicCodes$ que se almeja evitar, então afirma-se que o método é correto no que se propõem. Ou seja, dado um processo de indução estrutural em um $PCL_{back}$ compilado de uma linguagem que deseja evitar falhas espaciais, basta que na derivação nunca se atinjam as expressões $\KW{panic}\;\KW{OutofBoundsRead}$ e $\KW{panic}\;\mathbf{OutofBoundsWrite}$.

Na hora da escrita da linguagem, certos componentes não são acessíveis: $\KW{pop}$ e $\KW{Fpop}$ são gerados exclusivamente como consequência de $\{\}$ e de $f(\bar x)$ respectivamente; $l$ não pode ser escrita diretamente, para evitar a forja de metadados; $\KW{panic}$ não pode ser escrito para evitar a forja de erros. No caso de $l$, utiliza-se a expressão $\KW{NULL}$ para escrever o ponteiro nulo, sendo este o valor $l^m\{0, 0, 0, 0\}$. No caso de $\KW{panic}$, o $\KW{UserError}$ é o único panico de execução do usuário, assim, para gerá-lo usa-se a diretiva $PANIC$, que é equivalente a $\KW{panic}\;\KW{UserError}$.

%	3.2 Memory Model
\section{Modelo de Memória}

O layout de memória de um programa em C tem vários componentes\todo{Adicionar citação e um diagrama. Provavelmente retirar do livro de C}: o segmento de texto, que contém o programa em si; a seção de dados, que guarda elementos globais, assim como \emph{strings} literais e outros elementos escritos no código; a pilha e a \emph{heap}. A pilha é o lugar em que variáveis locais são alocadas e chamadas de funções são geridas. Ela realiza alocações de tamanho conhecido em tempo de compilação e libera essa memória no final do escopo da variável associada. A \emph{heap} é o lugar em que alocações dinâmicas são colocadas, seja porque o tamanho ou a duração não são conhecidos em tempo de compilação.

A dinâmica entre alocações manuais, aquelas que acontecem na \emph{heap}, e alocações estáticas, aquelas que acontecem na pilha, é um componente importante na reprodução de \emph{bugs} de memória. Falhas na \emph{heap} tendem a ser mais difíceis de encontrar e lidar, pois o processo de requisitar memória e liberá-la manualmente tende a aumentar a superfície de falhas. 

Com o intuito de modelar essa dinâmica, a memória em $PCL_{back}$ usa dois ambientes disjuntos, $p$ para modelar a pilha e $m$ para modelar a \emph{heap}, que, com o intuito de diminuir os estrangeirismos, poderá ser referida como memória a partir deste ponto. 

\subsection{Ponteiros}
\label{sec:pcl-back:ptr}

Com essa distinção, pode-se notar que o elemento da sintaxe responsável por indexar a memória, a localização $l$, é divida em $l^p$ e $l^m$. Nesse contexto, $p$ e $m$ são etiquetas de $l$ que indicam se essa localização é para a pilha ou para memória. Essas localizações também possuem outros metadados, utilizados na avaliação da linguagem para detectar as falhas. Assim, a representação interna dos locais pode ser escrita como:
\begin{figure*}[ht]
	\begin{align*}
		l^p\{i, k, o, s \} && l^m\{i, k, o, s \}
	\end{align*}
	\caption{Layout dos metadados dos locais.}
	\label{fig:ptr:metada}
\end{figure*}
\todo{Fazer um diagrama mais legal?}

Nela, $i$ é o índice de acesso à memória; $k$ é a uma chave única, gerada através da função $\mathbf{newkey}$, que serve para validar os acessos quanto a falhas temporais; $o$ é o \emph{offset} (desvio) do índice base $i$, que recebe o valor das somas e subtrações, ao invés de alterar o índice diretamente; e $s$ é o tamanho da região alocada na memória, que serve para validar os acessos quanto a falhas espaciais. Esses metadados não são acessíveis na escrita do código, mas na semântica operacional tem seus valores internos expostos à avaliação usando a anotação de chaves acima.

\subsection{Pilha}
\label{sec:pcl-back:pilha}

A pilha é uma lista de elementos, que podem ser valores $v \in \{l, n, \bot, -\}$ ou códigos de controle $c_{ctrl} \in \{\mathbf{stack},\mathbf{func}\}$. Dentre os valores, $l$ e $n$ são os elementos de locais e números da sintaxe da linguagem. $\bot$ e $-$, assim como em \citet{WESSEL2019}, são elementos utilizados na representação da inicialização de um valor, representando um espaço alocado, mas ainda não inicializado, e um espaço não alocado, respectivamente. 

Junto desses elementos guarda-se uma fechadura $k \in \mathbb{N}\text{*}$. Esse elemento serve para a checagem de falhas temporais, similar ao sistema de \emph{key-lock} \ref{sec:mem-error:KeyLock}. Para um acesso ser válido, é necessário que a chave $k$ do local $l$ que tenta acessar a célula seja igual à fechadura $k'$ salva junto ao valor na célula. Valor de controle, junto do $\bot$ e $-$ sempre são empilhados com a chave de valor 0 associada. Uma pilha $p$ da linguagem pode ser definida como uma lista de pares, com o primeiro elemento sendo ou um valor, ou um código de controle, e com o segundo elemento sendo a fechadura de acesso, tal como $p := [(v\,|\,c_{ctrl}, k)]$.

Os códigos de controle citados existem para essa lista se comportar como um pilha de um sistema. Quando se inicia um escopo, coloca-se no fim da lista um código de controle. Chegando no final desse escopo, removem-se elementos do final da lista até atingir o código escolhido, emulando a impermanência dos elementos de uma pilha. Na semântica, utiliza-se das funções $\mathbf{pop}_{stack}(p)$ e $\mathbf{pop}_{func}(p)$ para descrever a ação de remover os elementos da lista até o código de controle $\mathbf{stack}$ ou $\mathbf{func}$. Elas são definidas da seguinte forma:

\begin{figure}[ht]
	\begin{align}
		&\mathbf{pop}_{stack}(p) = \mathbf{pop}(p, stack) \label{fig:def:pop1}\\
		&\mathbf{pop}_{func}(p) = \mathbf{pop}(p, func) \label{fig:def:pop2}\\
		&\mathbf{pop}((v, \_) : t, c_{ctrl}) = \mathbf{if} \; v \neq c_{ctrl} \;\mathbf{then} \; \mathbf{pop}(t, c_{ctrl}) \; \mathbf{else} \; t  \label{fig:def:pop3}\\
		&\mathbf{pop}([], c_{ctrl}) =  [] \label{fig:def:pop4}
	\end{align}
	\caption{Função que define a operação $\mathbf{pop}$}
	\label{fig:def:pop}
\end{figure}

A notação para descrever as funções neste projeto é similar a Haskell \cite{HASKELL}, com casamento de padrões nos argumentos das funções e as definições recursivas. Para o caso acima, em \ref{fig:def:pop1} e \ref{fig:def:pop2} definem as funções $\mathbf{pop}_{stack}(p)$ e $\mathbf{pop}_{func}(p)$ com base na função $\mathbf{pop}(p, v)$, usando como valor inicial de $v$ os seus elementos subscritos. Em \ref{fig:def:pop3} e \ref{fig:def:pop4} realiza a lógica. Se os argumentos casarem o padrão $h : t$, que nesse contexto é a lista poder ser dividida entre o elemento no fim $(v, \_)$ e no restante $t$, então executa-se \ref{fig:def:pop3}. Se a lista for vazia, representada por $[]$, realiza-se \ref{fig:def:pop4}. $(v,\_)$ também é um casamento de padrão, que atribui o nome $v$ para o primeiro elemento da dupla, o valor, e descarta o segundo, a chave. Com esses elementos, \ref{fig:def:pop3} checa se o valor no fim da lista é igual ao código de controle $c_{ctrl}$, se é retorna o restante da lista $t$, se não chama $\mathbf{pop}(t, c_{ctr})$ recursivamente para o restante da lista. Isso descarta elementos do topo da lista até finalmente descartar o $c_{ctrl}$ ou, pela definição \ref{fig:def:pop4}, chegar no final e retorna a lista vazia.

Outras funções similares existem para descrever o acesso, inserção de elementos e edição de elementos na pilha. A inserção no topo da pilha, tal qual em Haskell, utiliza-se o símbolo $:$ como uma operação binária de valor e pilha para pilha. Escreve-se $v : p$ para realizar o empilhamento de $v$ em $p$, retornando $p'$ com $v$ no topo. Caso se deseje empilhar várias cópias de um elemento na pilha, subscreve-se este com um número indicando a quantidade. Dessa forma, escrever $\bot_n : p$ empilha $n$ vezes o valor $\bot$ no topo da pilha. 

O acesso a pilha $p$ na posição $i$, $p(i)$ é descrito pela função:

\begin{figure}[ht]
	\begin{align}
	&p(i) = \mathbf{get}(i, \mathbf{top}(p) - 1, p) \label{fig:def:px1}\\
	&\mathbf{get}(i, size, p_v : p_r) = \mathbf{if}\;i = size \;\mathbf{then}\;p_v\;\mathbf{else}\;\mathbf{get}(i, size - 1, p_r) \label{fig:def:px2}\\
	&\mathbf{get}(\_, \_, []) = (-,0) \label{fig:def:px3}
	\end{align}
	\caption{Função que define a operação de acesso $p(i)$.}
	\label{fig:def:px}
\end{figure}

A notação é similar a \ref{fig:def:pop}, usando a primeira expressão, \ref{fig:def:px1}, para chamar uma função auxiliar associada, neste caso $\mathbf{get(i, size, p)}$ com o índice de acesso $i$, o tamanho atual da pilha $size$ e a pilha $p$ em sí. \ref{fig:def:px1} checa se o índice é igual ao tamanho $size$, se sim retorna o fim da lista, ou seja, o topo da pilha, se não repete recursivamente para o restante da lista, com o $size - 1$. Isso se repete até $i = size$ ou, em \ref{fig:def:px3}, chegar no fim da pilha, retornando $(-,0)$, que representa o valor não inicializado.

A função auxiliar $\mathbf{top}(p)$ utilizada em \ref{fig:def:px1} retorna o tamanho da lista. Esse tamanho também pode ser interpretado como índice para o elemento acima do último elemento da lista. Esse fato é usado na notação da semântica operacional para gerar o índice das alocações na pilha \todo{Referir-se a regra let.}. Uma definição com a notação atual pode ser escrita como:

\begin{figure}[ht]
	\begin{align}
	&\mathbf{top}(\_ : t) = 1 + \mathbf{top}(t) \label{fig:def:top1}\\
	&\mathbf{top}([]) = 0 \label{fig:def:top2}
	\end{align}
	\caption{Função que calcula o tamanho da pilha $p$.}
	\label{fig:def:top}
\end{figure}

Essa é a definição clássica de calcular o tamanho de uma lista recursivamente. Adicionando 1 ao resultado até o final da lista, que retorna 0 para a conta.

Para inserir um valor $v$ na posição $i$ da pilha $p$, escreve-se $p[i \mapsto v]$. Essa operação retorna uma nova pilha $p'$ com o valor atualizado na posição. Ela é melhor visualizada como a operação de indexação e atribuição a um \emph{buffer} em C, da forma \lstinline[language=C]|p[i] = v|. Mas ao quesito de rigorosidade, também se define no estilo funcional da seguinte forma:

\begin{figure}[ht]
	\begin{align}
	&p[i \mapsto v] = \mathbf{set}(i, \mathbf{top}(p) - 1, v) \label{fig:def:set1}\\
	&\mathbf{set}(i, size, (v_p, k_p) : p_r) = \mathbf{if}\;i = size \;\mathbf{then} \nonumber\\ 
	&\quad\quad(v, k_p) : p_r\;\mathbf{else}\;(v_p, k_p) : \mathbf{set}(i, size - 1, p_r) \label{fig:def:set2}\\
	&\mathbf{get}(\_, \_, []) = [] \label{fig:def:set3}
	\end{align}
	\caption{Função que insere o valor $v$ na posição $i$ da pilha $p$.}
	\label{fig:def:set}
\end{figure}

Ela usa a notação de empilhamento ($:$) com toda a sua expressividade. Após em \ref{fig:def:set1} definir via uma função auxiliar a operação, \ref{fig:def:set2} checa se $i = size$, se for troca o topo da lista atual para uma dupla com a chave anterior e o novo valor. Se $i \neq size$, concatena o topo atual da pilha com o restante da operação. Isso resulta em uma pilha nova final $p'$ cujo único elemento diferente é o da posição de índice $i$. Caso o índice seja para fora da pilha, eventualmente \ref{fig:def:set3} será atingido, terminando a execução e retornando a pilha inalterada.

Uma notação alternativa, para quando se precisa alterar várias posições na pilha para um mesmo valor é $p[i_{m..n} \mapsto v]$. Similarmente a empilhar vários elementos do mesmo valor, essa definição altera os valores da posição $i + m$ até a posição $i + n - 1$ para o valor $v$.


\subsection{\emph{Heap}}
\label{sec:pcl-back:mem}

A memória (\emph{heap}) é extremamente similar a pilha, porém sem os códigos de controle. Partindo disso, a memória $m$ é uma lista de pares, valor $v \in \{n, l, \bot, -\}$ fechadura $k \in \mathbb{N}$, podendo ser escrito na forma $m := [(v, k)]$. Essa lista pode ser imaginada infinitamente grande, tendo todas as células inicializadas com o valor $-$.

As células da memória são manualmente liberadas com a função $\mathbf{free}$ e alocadas com a função $\mathbf{malloc}$. Essa última usa uma função auxiliar $mathbf{loc(m,n)}$ para encontrar na memória $m$, $n$ células contíguas não alocadas (com o valor $-$) e retorna o índice do começo dessa região. Ela é descrita mais formalmente da seguinte forma:

\begin{figure}[ht]
	\begin{align}
	&\mathbf{loc}(m,n) = \mathbf{loc}'(m, n, 0, 1) \label{fig:def:loc1}\\
	& \mathbf{loc}'(m, n_0 , n_1, i) = \mathbf{if}\; m(i + n_1) \neq (-,0) \; \mathbf{then}\nonumber \\
	&\quad\mathbf{loc}'(m, n_0, 0, i + n_1 + 1)\; \mathbf{else} \nonumber\\
	&\quad\quad(\mathbf{if}\; n_0 = n_1 \; \mathbf{then}\; i \;\mathbf{else}\; \mathbf{loc}'(m, n_0, n_1 + 1, i)) \label{fig:def:loc2}
	\end{align}
	\caption{Função encontra em $m$, $n$ contíguas células não alocadas.}
	\label{fig:def:loc}
\end{figure}

\noindent Ela primeiro chama uma função auxiliar em \ref{fig:def:loc1}, com 0 para $n_1$, o tamanho atual da região encontrada,  e 1 para $i$, o índice de início de busca. Parte-se do índice de número um, mesmo a indexação da lista iniciando no 0, pois se reserva esse espaço para a implementação do ponteiro nulo. Em \ref{fig:def:loc2} realiza-se a computação: se o valor no índice $i$ da memória $m$ mais o tamanho da região atual encontrada $n_1$ não for o par $(-,0)$ (célula não alocada), então reinicia a busca, partindo no índice seguinte ao analisado nesse teste; se não for o caso, verifica-se se já se encontrou a região do tamanho esperado, se sim, retorna o índice $i$, que é o índice do começo desta, se não, avalia-se a célula seguinte, chamando $\mathbf{loc}'$ recursivamente, incrementando o valor da região encontrada em 1.

Na definição dessa função, utilizou-se a expressão $m(i)$ para indicar o acesso ao elemento de índice $i$ da memória $m$. Assim como o acesso na pilha, essa operação pode ser vista como uma simples indexação a um \emph{buffer}. Neste caso, como há a intuição da memória ser infinita, para qualquer índice $i$ há uma célula correspondente na memória. Como todas elas iniciam com o valor $(-,0)$, o comportamento de acessar para além do espaço alocado é o mesmo de quando isso acontece na pilha. A atribuição segue o mesmo padrão, inserir o valor $v$ no índice $i$ da memória $m$ é escrito como $m[i \mapsto v]$. Aqui omiti-se a definição porque estas são (quase) idênticas às definições da pilha, visto que a memória não pode ser realmente infinita. O mesmo segue para a atribuição de várias células com a notação $m[i_{m..n} \mapsto v]$ cujo comportamento é o mesmo que na pilha, porém no contexto da memória essa função é mais usada, visto que é  instrumental as definições de $\mathbf{malloc}$ e $\mathbf{free}$.


%	3.3 Operational Semantics
\section{Semântica Operacional}
\label{sec:pcl-back:semantica}

A linguagem $PCL_{back}$ é definida por meios de semântica operacional estrutural, que especifica uma relação de um passo entre configurações (estados). Ela é subdividida em 3 avaliações: a avaliação dos globais, com o fecho transitivo $\to_G$, a avaliação das funções, com o fecho transitivo $\to_F$ e a avaliação das expressões, ou melhor, o programa em si, com o fecho $\to$. Um programa $P$ de $PCL_{front}$ pode ser visto como uma lista de declarações de variáveis globais, seguida de uma lista de declarações de funções globais, seguida da função de entrada do programa, como demonstra \ref{fig:tree-structure}.

\begin{figure*}[ht]
	\centering
	\begin{tikzpicture}[
		squarednode/.style={rectangle, draw=red!60, fill=red!5, very thick, minimum size=5mm},
	]
		%Nodes
		\node (G0) {$\KW{global}\;x[n]\; G$};
		\node (GtoF) [right=of G0] {$\;\KW{global}\;x[n]\; F$};
		\node (F0) [below=of GtoF] {$\KW{let}\;f(\bar x)\;e\;F$};
		\node (FtoE) [right=of F0] {$\;\KW{let}\;()$};
		\node (E) [right=0cm of FtoE] {$e$};
		
		%Lines
		\draw[->] (G0.east) -- (GtoF.west) node[at end, above] () {$*$} node[at end, below] () {G};

		\draw[->] (F0.east) -- (FtoE.west) node[at end, above] () {$*$} node[at end, below] () {F};

		\draw[->] (GtoF.south)  -- (F0.north);

		\node[draw, dotted, fit=(G0) (GtoF) (F0) (FtoE) (E), inner sep=0.1cm, label={[anchor=south east, xshift=12mm]north west:Globais}] {};

		\node[draw, dashed, fit=(F0) (FtoE) (E), inner sep=0.1cm, label={[anchor=south east, xshift=12mm]north west:Funções}] {};

		\node[draw, fit=(E), inner sep=0.1cm, label={[anchor=south east, xshift=12mm]north west:Programa}] {};
	\end{tikzpicture}
	\caption{Árvore de um programa em $PCL_{back}$.}
	\label{fig:tree-structure}
\end{figure*}

Dessa forma, um programa $P$ coleta primeiro todas as globais, depois coleta todas as funções e com essas informações computa o resultado do programa $e$. O asterisco indicado acima dos fechos transitivos indica que $n$ ou mais passos foram tomados até atingir o resultado a direita. O diagrama pode ser mais formalmente descrito como:

\labelRule{\label{rule:run}}{
\infrule[Run]
    {\St{P, \{\}, []} \to_G^* \St{F_0, g, p}\quad\St{F_0, \{\}} \to_F^* \St{\mathbf{let}\;()\;e , F}}
    {F \vdash \St{\{e\}, ([],g),p,[]} \to^* \St{v, ([],g), p, m}} 
}
\noindent Dizendo que, para avaliar a expressão $e$ sob um escopo $\{\}$, é necessário primeiro avaliar sequencialmente as globais e as funções, usando essas informações na computação de $e$.

Essa computação de $e$ é o fecho transitivo $\to$, que descreve a transição do estado $\St{e, a, p, m}$ para o estado $\St{e', a', p', m'}$ sob a definição do ambiente global de funções $F$. Isso totaliza a expressão $F \vdash \St{e, a, p, m} \to \St{e', a', p', m'}$. Nesse contexto, $F$ é o ambiente global de funções, $e$ é o programa (expressão) a ser computado, $a$ é o ambiente de nomes, $p$ é a pilha, como descrita em \ref{sec:pcl-back:pilha}, e $m$ é a memória, como descrita em \ref{sec:pcl-back:mem}.

\subsection{Globais}
\label{sec:pcl-back:semantica:globals}

As globais do programa são declaradas todas juntas no começo do programa. Para isso, define-se o fecho transitivo $\to_G$ da seguinte forma:

\labelRule{\label{rule:globals-collect}}{
\infrule[Globals-collect]
    {\mathbf{newkey}() = k \quad \mathbf{top}(p) = i}
    {\St{\mathbf{global} \; x[n]\; G , g, p} \to_G\\ \St{G, g[x \mapsto l^p \{i, k, 0, n\}],(\bot, k)_n : p,}} 
}

\noindent Dada a declaração $\KW{global}\;x[n]$, empilha-se no topo da pilha $n$ vezes a dupla $(\bot, k)$ representando $n$ posições alocadas, mas não inicializadas, que só podem ser acessadas com um ponteiro que tenha uma chave de valor $k$. Para associar o nome $x$ a essa posição na pilha, salva o local construído com os metadados gerados no ambiente de nomes globais $g$.

Esse ambiente, $g$, é um mapa de nomes a locais na pilha, podendo ser escrito como $g := Map\;nome\;l^p$. Obter o valor associado a um nome $x$ no mapa $g$, escreve $g(x)$. Essa operação  retorna $-$ quando $x \notin g$. Atribuir um valor no mapa usa a mesma notação das atribuições nos demais ambiente. Para atribuir o local $l^p$ ao nome $x$ no mapa $g$, escreve-se $g[x \mapsto l^p]$. 

A regra (\hyperref[rule:globals-collect]{GLOBALS-COLLECT}) executa até que o elemento $G$ sequente seja uma função (\ref{fig:tree-structure}). Ao chegar nesse ponto, a execução está finalizada e o ambiente de nomes globais foi construído e os valores foram empilhados na base da pilha. O ambiente gerado $g$ é apenas um elemento da dupla que compõe o ambiente de nomes na execução do programa. 

A outra parte é o ambiente de nomes locais $a_l$. Este, é uma pilha de mapas, nome - local na pilha, e códigos de controle $STOP$. Esses mapas são definidos exatamente igual ao ambiente global de nomes. O uso do $STOP$ serve para delimitar acessos apenas as variáveis alcançáveis naquele ponto do programa, fazendo $PCL_{back}$ ter um escopo estático. Adicionar elementos no topo de $a_l$ usa a mesma notação de lista usada na pilha. Para encontrar o valor associado com o nome $x$ em $a_l$, realiza-se uma busca nos mapas em ordem até ou chegar a um código de controle $STOP$, ou até chegar na base da pilha. Dessa forma, define-se o acesso ao valor associado a uma variável $x$ no ambiente de nomes completo $a$, que é o par $(a_l, g)$, como $a(x)$, descrito como:

\begin{figure}[ht]
	\begin{align}
		&(map : a_l, g)(x) = \mathbf{if}\; map(x) \neq - \;\mathbf{then}\; map(x) \;\mathbf{else}\; (a_r, g)(x)\label{fig:def:amb:acess1}\\
		&(STOP \;:\;a_l, g)(x) = g(x) \label{fig:def:amb:acess2}\\
		&([], g)(x) = g(x)\label{fig:def:amb:acess3}
	\end{align}
	\caption{Função que obtém o local da pilha em $a$ associado a variável $x$. }
	\label{fig:def:amb:acess}
\end{figure}

Em \ref{fig:def:amb:acess1}, se $x$ existir no mapa no topo de $a_l$, retorna esse valor. Se não, repete para o restante de $a_l$ até encontrar um valor ou parar, via código de controle $STOP$ (\ref{fig:def:amb:acess2}) ou via fim de $a_l$ (\ref{fig:def:amb:acess3}). No caso de parada, obtém-se o valor associado de $x$ no ambiente de nomes globais.

Não há função específica para alterar o valor de um nome $x$ em $a$. Para realizar essa operação, obtém-se o valor no topo da pilha, que é um mapa, e usa-se a notação de atribuição de mapa para esse processo. Isso limita a atribuição em $a$ para apenas o mapa no topo da pilha, ou próximo do topo. Isso não é problema, pois no contexto de $PCL_{back}$, o valor associado a um nome no ambiente não é modificado após a sua inserção inicial, que sempre ocorrerá no topo. A remoção de nomes consiste em desempilhar o topo de $a_l$, casando o padrão e retornando a cauda.

\subsection{Funções}

O passo seguinte, após a avaliação das globais, é o de captura das funções. Para isso, define-se o fecho transitivo $\to_F$ da seguinte forma:

\labelRule{\label{rule:func-collect}}{
\infrule[LetFunction-collect]
    {}
    {\St{\mathbf{let} \; f(\overline{x_i})\; e \; F_0 ,F} \to_F \St{F_0, F[f \mapsto \St{[\overline{x_i}], e}]}}
}
\noindent O fecho apenas captura a lista de nomes de argumentos $\bar x_i$ e o corpo da função $e$ e associa eles ao nome $f$ desta no ambiente $F$, tal como $F[f \mapsto \St{[\bar x_i], e}]$. Tanto a notação de atribuição quanto a notação de acesso são iguais ao do ambiente global de nomes $g$, pois $F$ também é um mapa, só que este é um mapa de nomes de funções $f$ para duplas, lista dos nomes dos argumentos - corpo da função, $\St{[\bar x_i], e}$. Ou seja, pode-se definir $F$ com a expressão $F := Map\;f\; \St{[\bar x_i], e}$.

Essa operação de coleta continua até chegar na função principal do programa, escrita como $\KW{let}\;()\; e$. A esse ponto, realiza-se a avaliação do programa sob o ambiente de funções globais $F$ gerado. 

\subsection{Expressões}

A avaliação das expressões começa com um ambiente de funções globais já formado, assim como uma pilha e ambiente de nomes com valores advindos da avaliação das globais. A memória é inicializada vazia, mas como elaborado em \ref{sec:pcl-back:mem}, virtualmente todas as células já possuem o valor $(-, 0)$. 

As regras podem ser dividas por funcionalidade. Assim, tem-se a semântica da linguagem da forma:

\subsubsection{Regras de Composição}

Mesmo sendo uma semântica de expressões, a linguagem segue o padrão de C e possui operadores de composição $;$ e de escopo $\{\}$. O escopo é importantíssimo na emulação das falhas de memória, principalmente quanto se diz a falhas de \emph{Use-After-Free}. Dessa forma, têm-se as regras de composição:

\labelRule{\label{rule:compose-s}}{
	\infrule[Compose-s]
		{F \vdash \St{e_1,a, p, m} \to \St{e_1',a', p', m'}}
		{F \vdash \St{e_1;e_2,a, p, m} \to \St{e_1';e_2,a', p', m'}}
}

\labelRule{\label{rule:compose}}{
	\infrule[Compose]
		{}
		{F \vdash \St{v;e, a, p, m} \to \St{e, a, p, m}}
}

\labelRule{\label{rule:escopo}}{
	\infrule[Escopo]
		{}
		{F \vdash \St{\{e\},(a,g), p, m} \to \\ \St{\mathbf{pop}\; e,(\{\} : a, g),\mathbf{stack} : p, m}}
}

\labelRule{\label{rule:pop-s}}{
	\infrule[Pop-s]
		{F \vdash \St{e,a, p, m} \to \St{e',a', p', m'}}
		{F \vdash \St{\mathbf{pop}\;e,a, p, m} \to \St{\mathbf{pop}\;e',a', p', m'}} 
}

\labelRule{\label{rule:pop}}{
	\infrule[Pop]
		{\mathbf{pop}_{stack}(p) = p'}
		{F \vdash \St{\mathbf{pop}\;v,(frame : a, g), p, m} \to\\\St{v,(a, g), p', m}}
}

As regras \hyperref[rule:pop-s]{(COMPOSE-S)} e \hyperref[rule:compose-s]{(POP-S)} indicam o passo (\emph{step}) de avaliação da regra. Assim, a composição, por exemplo, primeiro avalia o primeiro elemento até que este seja um valor, descartando esse e resultando no segunda elemento, como descreve \hyperref[rule:compose]{(COMPOSE)}. Como convenção deste trabalho, regras terminadas por S são regras de passo e se prefixadas com R ou L indicam um passo do elemento da direita (\emph{right}) ou do elemento da esquerda (\emph{left}) respectivamente.

A regra \hyperref[rule:escopo]{(ESCOPO)} utiliza-se da expressão auxiliar $\KW{pop}$ para diferenciar a sua inicialização, empilhar um mapa novo em $a$ e o código de controle $\mathbf{stack}$ em $p$, da avaliação desse escopo, pois a inicialização só acontece uma vez. No fim, com a regra \hyperref[rule:pop]{(POP)}, remove-se o mapa inserido em $a$ por \hyperref[rule:escopo]{(ESCOPO)}, assim como todos os elementos colocados no topo da pilha acima do código de controle $\mathbf{stack}$ inserido, e retorna-se o valor avaliado dentro do escopo.

\subsubsection{Regras de Declaração e Atribuição}
\label{sec:pcl-back:semantica:atribui}

As declarações de variáveis na pilha, com a palavra-chave $\KW{let}$, operam muito similarmente a regra \hyperref[rule:globals-collect]{(GLOBALS-COLLECT)}. Entretanto \hyperref[rule:let]{(LET)} salva o local gerado no mapa no topo de $a_l$ de $a$. 

\labelRule{\label{rule:let}}{
	\infrule[Let]
		{\mathbf{top}(p) = i \andalso \mathbf{newkey}() = k \andalso l = l^p\{i, k, 0, n\}}
		{F \vdash \St{\mathbf{let}\; x[n],(fr : a, g), p, m} \to\\ \St{l, (fr[x \mapsto l] : a, g),(\bot, k)_n : p, m}} 
}

Como $PCL_{back}$ é uma linguagem de expressões, todas elas precisam retornar algum valor. \hyperref[rule:let]{(LET)} avalia para o endereço alocado na pilha $l$. A decisão de qual elemento a expressão seria avaliada, para os casos menos comuns, foi baseada no comportamento de C. Se a expressão equivalente não avalia para um valor em C, decidiu-se basear no comportamento em OCaml, principalmente para as regras \hyperref[rule:if-true]{(IF-TRUE)}, \hyperref[rule:if-false]{(IF-FALSE)} e \hyperref[rule:while]{(WHILE)}.

Para as atribuições, pode-se realizá-las quando o elemento da esquerda avalia para uma variável ou para um local, prefixado pelo operador de dereferência, tal como $\text{*}l := e$. A ordem dessa operação é definida como primeiramente avalia-se completamente o termo da esquerda para depois avaliar o termo da direita, exemplificado por \hyperref[rule:atribui-deref-ls]{(ATRIBUI-DEREF-LS)} e \hyperref[rule:atribui-deref-rs]{(ATRIBUI-DEREF-RS)}.

\labelRule{\label{rule:atribui-deref-ls}}{
	\infrule[Atribui-deref-ls]
		{F \vdash \St{e_1,a, p, m} \to \St{e_1', a', p', m'}}
		{F \vdash \St{\text{*}e_1 := e_2, a, p, m} \to \St{\text{*}e_1' := e_2, a', p', m'}} 
}

\labelRule{\label{rule:atribui-var-rs}}{
	\infrule[Atribui-var-rs]
		{F \vdash \St{e, a, p, m} \to \St{e', a', p', m'}}
		{F \vdash \St{x := e, a, p, m} \to \St{x := e', a', p', m'}} 
}

\labelRule{\label{rule:atribui-deref-rs}}{
	\infrule[Atribui-deref-rs]
		{F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
		{F \vdash \St{\text{*}l := e, a, p, m} \to \St{\text{*}l := e', a', p', m'}} 
}

\labelRule{\label{rule:atribui-var-obe}}{
	\infrule[Atribui-var-obe]
		{a(x) = l^p\{i, k, o, s\} \andalso 0 > o \ge s}
		{F \vdash \St{x := v, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsWrite}, a, p, m}}
}
    
\labelRule{\label{rule:atribui-var-deref}}{
	\infrule[Atribui-var-uaf]
		{a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\andalso p(i + o) = (v_p, k_p) \andalso k \neq k_p }
		{F \vdash \St{x := v, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}}
}

\labelRule{\label{rule:atribui-var}}{
	\infrule[Atribui-var]
		{a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p }
		{F \vdash \St{x := v, a, p, m} \to \St{v, a, p[i + o \mapsto v], m}} 
}

\labelRule{\label{rule:atribui-deref-pilha-obe}}{
	\infrule[Atribui-deref-pilha-obe]
		{0 > o \ge s}
		{F\vdash\St{\text{*}l^p\{i, k, o, s\} := v, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsWrite}, a, p, m}} 
}

\labelRule{\label{rule:atribui-deref-pilha-uaf}}{
	\infrule[Atribui-deref-pilha-uaf]
		{0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k \neq k_p }
		{F\vdash\St{\text{*}l^p\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}} 
}

\labelRule{\label{rule:atribui-deref-pilha}}{
	\infrule[Atribui-deref-pilha]
		{0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p }
		{F\vdash\St{\text{*}l^p\{i, k, o, s\} := v, a, p, m} \to\\ \St{v, a, p[i + o \mapsto v], m}} 
}

\labelRule{\label{rule:atribui-deref-mem-npd}}{
	\infrule[Atribui-deref-mem-npd]
		{i = 0}
		{F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{NullPtrDeref}, a, p, m}} 
}

\labelRule{\label{rule:atribui-deref-mem-obe}}{
\infrule[Atribui-deref-mem-obe]
    {i \neq 0 \quad 0 > o \ge s}
    {F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsWrite}, a, p, m}} 
}

\labelRule{\label{rule:atribui-deref-mem-uaf}}{
	\infrule[Atribui-deref-mem-uaf]
		{i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k \neq k_m }
		{F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}} 
}

\labelRule{\label{rule:atribui-deref-mem}}{
	\infrule[Atribui-deref-mem]
		{i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k = k_m }
		{F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to \\\St{v, a, p, m[i + o \mapsto v]}}
}

Várias dessas regras tratam do sistema de detecção de memória, que será elaborado em \ref{sec:pcl-back:errors}. Mas a avaliação final de uma atribuição, como na regra \hyperref[rule:atribui-var]{(ATRIBUI-VAR)}, consiste em atribuir o valor no espaço de memória especificado, avaliando para esse mesmo valor a fim de permitir padrões como $x := y := 2$, que atribui para $x$ e $y$ o número 2.

\subsubsection{Funções de Memória}
\label{sec:pcl-back:semantica:mem-func}

As funções de memória $\KW{malloc}$ e $\KW{free}$ operam sobre o ambiente $m$. $\KW{malloc}(e)$ recebe como argumentos quantas células de memórias serão alocadas, usando a função auxiliar \hyperref[fig:def:loc]{$\KW{loc}$}. $\KW{free}(e_1, e_2)$ por sua vez recebe dois argumentos, o local que inicia a região a ser liberada em $e_1$ e o número de células a serem liberadas em $e_2$. Esse segundo argumento é necessário, pois não se utiliza de mecanismo macro para guardar quais alocações foram feitas no programa, apenas a visão micro de quais células foram alocadas.

\labelRule{\label{rule:malloc-s}}{
	\infrule[Malloc-s]
		{F\vdash\St{e, a, p, m} \to\St{e', a', p', m'}}
		{F\vdash\St{\mathbf{malloc}(e),a, p, m} \to\St{\mathbf{malloc}(e'),a', p', m'}}
}  

\labelRule{\label{rule:malloc}}{
	\infrule[Malloc]
		{\mathbf{loc}(m, n) = i \quad \mathbf{newkey}() = k \quad l = l^m\{i, k, 0, n\}}
		{F\vdash\St{\mathbf{malloc}(n),a, p, m} \to\St{l, a, p, m[i_{0..n} \mapsto (\bot,k)]}} 
}

\labelRule{\label{rule:free-ls}}{
	\infrule[Free-ls]
		{F\vdash\St{e_1, a, p, m} \to\St{e_1', a', p', m'}}
		{F\vdash\St{\mathbf{free}(e_1, e_2),a, p, m} \to\St{\mathbf{free}(e_1', e_2),a', p', m'}}
}
    
\labelRule{\label{rule:free-rs}}{
	\infrule[Free-rs]
		{F\vdash\St{e, a, p, m} \to\St{e', a', p', m'}}
		{F\vdash\St{\mathbf{free}(l, e),a, p, m} \to\St{\mathbf{free}(l, e'),a', p', m'}} 
}

\labelRule{\label{rule:free-mnh}}{
	\infrule[Free-mnh]
		{}
		{F\vdash\St{\mathbf{free}(l^p, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{FreeMemoryNotOnHeap},a, p, m}}
}

\labelRule{\label{rule:free-null}}{
	\infrule[Free-null] 
		{i = 0}
		{F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{FreeMemoryNotOnHeap},a, p, m}}
}

\labelRule{\label{rule:free-partial}}{
	\infrule[Free-parcial] 
		{i \neq 0 \quad o \neq 0 \lor s \neq n}
		{F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{PartialFree},a, p, m}}
}

\labelRule{\label{rule:free-double}}{
\infrule[Free-double]
    {i \neq 0 \quad o = 0 \quad s = n \quad m(i) = (v_m, k_m) \quad k \neq k_m}
    {F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{DoubleFree},a, p, m}}
}

\labelRule{\label{rule:free}}{
	\infrule[Free]
		{i \neq 0 \quad o = 0 \quad s = n \quad m(i) = (v_m, k_m) \quad k = k_m}
		{F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\St{n,a, p, m[i_{0..n} \mapsto (-,0)]}}
}

\subsubsection{Expressões Aritméticas}

As expressões aritméticas de $PCL_{back}$ são as operações binárias $op \in BinOp$, assim como o operador unário $!$, a negação booleana. No caso das operações binárias, elas avaliam primeiro o elemento da esquerda completamente para depois avaliar o elemento da direita. Para simplificar a definição dessas regras, utiliza-se de algumas funções auxiliares: $\mathbf{binop}(op, v_1, v_2)$, $\mathcal{N}(n)$ e $\mathcal{N}^{-1}(N)$. 

$\mathcal{N}(n)$ é a função que converte o símbolo da linguagem $n$ em um número matemático $N \in \mathbb{z}$. O inverso, ir de um número matemático $N$ para um número da sintaxe, é realizado com a operação $\mathcal{N}^{-1}(N)$. A função $\mathbf{binop}(op, v_1, v_2)$ define a operação $op$ entre valores $v_1$ e $v_2$ da linguagem, sendo definido da seguinte forma:

\begin{figure}[ht]
	\begin{align}
		& \mathbf{binop}(op, n_1, n_2) = \mathcal{N}^{-1}(\mathbf{binop}'(op, \mathcal{N}(n_1), \mathcal{N}(n_2))) \\
		& \mathbf{binop}(op, n, l^{local}\{i, k, o, s\}) = l^{local}\{i, k, \mathbf{binopnptr}(op, \mathcal{N}(n), o), s\} \\
		& \mathbf{binop}(op, l^{local}\{i, k, o, s\}, n) = l^{local}\{i, k, \mathbf{binopnptr}(op, \mathcal{N}(n), o), s\} \\
		& \mathbf{binop}(op, l^p\{i_1, k_1, o_1, s_1\}, l^p\{i_2, k_2, o_2, s_2\}) = \nonumber \\ 
		&\quad\quad\mathcal{N}^{-1}(\mathbf{binopcomp}(op, i_1 + o_1, i_2 + o_2)) \\
		& \mathbf{binop}(op, l^m\{i_1, k_1, o_1, s_1\}, l^m\{i_2, k_2, o_2, s_2\}) = \nonumber \\ 
		&\quad\quad\mathcal{N}^{-1}(\mathbf{binopcomp}(op, i_1 + o_1, i_2 + o_2)) 
	\end{align}
	\caption{Definição da base de $\mathbf{binop}$}
	\label{fig:def:binop:base}
\end{figure}

Ela define as operações por tipo de dados. Todos os $op \in BinOp$ são definidos para dois números, identificado pela função $\KW{binop}'$ (\ref{fig:def:binop1} a \ref{fig:def:binop2}). Apenas soma e subtração são definidos entre ponteiros e números, identificado pela função $\KW{binopnptr}$ (\ref{fig:def:binop3} e \ref{fig:def:binop4}). Pode-se observar na notação que os metadados do ponteiro são números matemáticos, então não é necessário chamar $\mathbb{N}$ neles. Por fim, entre ponteiros para o mesmo ambiente é definido operações de comparação, definida para a base $i$ mais o desvio $o$, retornando um número. Essa operação é definida pela função $\KW{binopcomp}$ (\ref{fig:def:binop5}, \ref{fig:def:binop6} e \ref{fig:def:binop7}). A linguagem usa o número 0 como o valor de falsidade e qualquer outro inteiro como o valor de veracidade.

\begin{figure}[ht]
	\begin{align}
		& \mathbf{binop}'(+, N_1, N_2) = N_1 + N_2 \label{fig:def:binop1}\\
		& \mathbf{binop}'(-, N_1, N_2) = N_1 + N_2\\
		& \mathbf{binop}'(*, N_1, N_2) = N_1 + N_2\\
		& \mathbf{binop}'(<, N_1, N_2) = \mathbf{if}\; N_1 < N_2 \;\mathbf{then}\; 1 \;\mathbf{else} \;0\\
		& \mathbf{binop}'(>, N_1, N_2) = \mathbf{if}\; N_1 > N_2 \;\mathbf{then}\; 1 \;\mathbf{else} \;0\\
		& \mathbf{binop}'(=, N_1, N_2) = \mathbf{if}\; N_1 = N_2 \;\mathbf{then}\; 1 \;\mathbf{else} \;0\\
		& \mathbf{binop}'(\land, N_1, N_2) = \mathbf{if}\; N_1 \neq 0 \;\mathbf{then}\; (\mathbf{if}\; N_2 \neq 0 \;\mathbf{then}\; 1 \;\mathbf{else} \;0) \;\mathbf{else} \;0\\
		& \mathbf{binop}'(\lor, N_1, N_2) = \mathbf{if}\; N_1 \neq 0 \;\mathbf{then}\; 1 \;\mathbf{else} \;(\mathbf{if}\; N_2 \neq 0 \;\mathbf{then}\; 1 \;\mathbf{else} \;0) \label{fig:def:binop2}\\
		\nonumber \\
		& \mathbf{binopnptr}(+, N_1, N_2) = N_1 + N_2  \label{fig:def:binop3}\\
		& \mathbf{binopnptr}(-, N_1, N_2) = N_1 + N_2  \label{fig:def:binop4}\\
		\nonumber \\
		& \mathbf{binopcomp}(<, N_1, N_2) = \mathbf{if}\; N_1 < N_2 \;\mathbf{then}\; 1 \;\mathbf{else} \;0  \label{fig:def:binop5}\\
		& \mathbf{binopcomp}(>, N_1, N_2) = \mathbf{if}\; N_1 > N_2 \;\mathbf{then}\; 1 \;\mathbf{else} \;0  \label{fig:def:binop6}\\
		& \mathbf{binopcomp}(=, N_1, N_2) = \mathbf{if}\; N_1 = N_2 \;\mathbf{then}\; 1 \;\mathbf{else} \;0  \label{fig:def:binop7}
	\end{align}
	\caption{Definição das funções auxiliares a $\mathbf{binop}$}
	\label{fig:def:binop:extra}
\end{figure}
\FloatBarrier

Além disso, existe também a função $\KW{not}$ nega o valor de um número, tal como: 
\begin{figure}[ht]
	\begin{align}
		\mathbf{not}(n) = \mathcal{N}^{-1}(\mathbf{if}\; \mathcal{N}(n) \neq 0 \;\mathbf{then}\; 0 \;\mathbf{else} \;1)
	\end{align}
	\caption{Função auxiliar $\mathbf{not}$}
	\label{fig:def:not}
\end{figure}
\FloatBarrier

Com essas funções, pode-se definir as regras da seguinte forma:

\labelRule{\label{rule:binop-ls}}{
	\infrule[BinOp-ls]
		{F \vdash \St{e_1,a, p, m} \to \St{e_1', a', p', m'}}
		{F \vdash \St{e_1 \;op\; e_2, a, p, m} \to \St{e_1' \;op\; e_2, a', p', m'}} 
}

\labelRule{\label{rule:binop-rs}}{
	\infrule[BinOp-rs]
		{F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
		{F \vdash \St{v \;op\; e, a, p, m} \to \St{v \;op\; e', a', p', m'}}
}

\labelRule{\label{rule:binop}}{
	\infrule[BinOp]
		{\mathbf{binop}(op, v_1, v_2) = v'}
		{F \vdash \St{v_1 \;op\; v_2, a, p, m} \to \St{v', a, p, m}}
}

\labelRule{\label{rule:not-s}}{
	\infrule[Not-s]
		{F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
		{F \vdash \St{!e, a, p, m} \to \St{!e', a', p', m'}}
}

\labelRule{\label{rule:not}}{
	\infrule[Not]
		{\mathbf{not}(n) = n'}
		{F \vdash \St{!n, a, p, m} \to \St{n', a, p, m}}
}

\subsubsection{Acesso a Valores}
\label{sec:pcl-back:semantica:acessa}

O acesso a valores consiste nas regras de acesso a valores de variáveis \hyperref[rule:var]{(VAR)}, dereferência de valores na pilha \hyperref[rule:deref-pilha]{(DEREF-PILHA)} e na memória \hyperref[rule:deref-mem]{(DEREF-MEM)}. Elas acessam a respectiva memória do valor associado, retornando o valor. 

\labelRule{\label{rule:var-obr}}{
	\infrule[Var-obr]
		{a(x) = l^p\{i, k, o, s\} \quad 0 > o \ge s}
		{F \vdash \St{x, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsRead}, a, p, m}}
}
    
\labelRule{\label{rule:var-uaf}}{
	\infrule[Var-uaf]
		{a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k \neq k_p}
		{F \vdash \St{x, a, p, m} \to \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}}
}

\labelRule{\label{rule:var-ua}}{
	\infrule[Var-ua]
		{a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p = \bot}
		{F \vdash \St{x, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{UninitializedAcess}, a, p, m}} 
}

\labelRule{\label{rule:var}}{
	\infrule[Var]
		{a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p \neq \bot}
		{F \vdash \St{x, a, p, m} \to \St{v_p, a, p, m}}
}

\labelRule{\label{rule:deref-s}}{
	\infrule[Deref-s]
		{F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
		{F \vdash \St{\text{*}e, a, p, m} \to \St{\text{*}e', a', p', m'}} 
}

\labelRule{\label{rule:deref-pilha-obr}}{
	\infrule[Deref-pilha-obr]
		{0 > o \ge s}
		{F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsRead}, a, p, m}}
}
    
\labelRule{\label{rule:deref-pilha-uaf}}{
	\infrule[Deref-pilha-uaf]
		{0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k \neq k_p}
		{F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}} 
}

\labelRule{\label{rule:deref-pilha-ua}}{
	\infrule[Deref-pilha-ua]
		{0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p = \bot}
		{F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UninitializedAcess}, a, p, m}}
}

\labelRule{\label{rule:deref-pilha}}{
	\infrule[Deref-pilha]
		{0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p \neq \bot}
		{F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to \St{v_p, a, p, m}}
}

\labelRule{\label{rule:deref-mem-null}}{
	\infrule[Deref-mem-null]
		{i = 0}
		{F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{NullPtrDeref}, a, p, m}}
}

\labelRule{\label{rule:deref-mem-obr}}{
	\infrule[Deref-mem-obr]
		{i \neq 0 \quad 0 > o \ge s}
		{F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsRead}, a, p, m}}
}

\labelRule{\label{rule:deref-mem-uaf}}{
	\infrule[Deref-mem-uaf]
		{i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k \neq k_m}
		{F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}}
}

\labelRule{\label{rule:deref-mem-ua}}{
	\infrule[Deref-mem-ua]
		{i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k = k_m \quad v_m = \bot}
		{F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UninitializedAcess}, a, p, m}} 
}
    
\labelRule{\label{rule:deref-mem}}{
	\infrule[Deref-memória]
		{i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k = k_m \quad v_m \neq \bot}
		{F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to \St{v_m, a, p, m}}
}

\labelRule{\label{rule:ref}}{
	\infrule[Ref]
		{a(x) = l^p}
		{F \vdash \St{\&x, a, p, m} \to \St{l^p, a, p, m}}
}

Adicionalmente há a regra para se obter o endereço de uma variável \hyperref[rule:ref]{(REF)}. Ela é similar a \hyperref[rule:var]{(VAR)}, porém ao invés de pegar o valor do local associado ao nome $x$, ela retorna esse local.

\subsubsection{Condicionais}

A linguagem se usa de um $\KW{if}$ expressão\emph{lazy}. Ou seja, ele computa o caminho a ser tomado, avaliando o condicional \hyperref[rule:if-s]{(IF-S)}, e retorna a expressão correspondente sem avaliar, \hyperref[rule:if-true]{(IF-TRUE)} e \hyperref[rule:if-false]{(IF-FALSE)}. Dessa forma, a expressão $x := \KW{if}\;(1)\; 1 + 1 \;\KW{else}\; 0$ avalia, em um passo, para $x := 1 + 1$.


\labelRule{\label{rule:if-s}}{
	\infrule[If-s]
		{F \vdash \St{e_1,a, p, m} \to \St{e_1', a', p', m'}}
		{F \vdash \St{\mathbf{if}\;(e_1)\; e_2\; \mathbf{else}\; e_3 ,a, p, m} \to\\ \St{\mathbf{if}\;(e_1')\; e_2\; \mathbf{else}\; e_3 ,a', p', m'}}
}

\labelRule{\label{rule:if-true}}{
	\infrule[If-true]
		{\mathcal{N}(n) \neq 0}
		{F \vdash \St{\mathbf{if}\;(n)\; e_1\; \mathbf{else}\; e_2 ,a, p, m} \to \St{e_1, a, p, m}} 
}

\labelRule{\label{rule:if-false}}{
	\infrule[If-false]
		{\mathcal{N}(n) = 0}
		{F \vdash \St{\mathbf{if}\;(n)\; e_1\; \mathbf{else}\; e_2 ,a, p, m} \to \St{e_2, a, p, m}} 
}
    
\labelRule{\label{rule:while}}{
	\infrule[While]
		{}
		{F \vdash \St{\mathbf{while}\;(e_1)\; e_2, a, p, m} \to \\ \St{\mathbf{if}\;(e_1)\; (e_2;\mathbf{while}\;(e_1)\; e_2)\; \mathbf{else}\; 0, a, p, m}} 
}

O $\KW{while}$ é definido em função do $\KW{if}$, tal qual a regra \hyperref[rule:while]{(WHILE)} descreve. Ele se deriva em um passo para um condicional que se verdadeiro resulta no corpo do $\KW{while}$ seguido da expressão inicial e se falso no valor 0. Seguindo o modelo OCaml \cite{leroy3ocaml}, $\KW{while}$ deveria retornar o tipo $Unit$. Como $PCL_{back}$ não possui tipos, pode-se interpretar o 0 como o $Unit$. Talvez uma interpretação melhor para o retorno de 0 no caso falso é que 0 é o valor da condicional computada quando se para de iterar o loop.

\subsubsection{Chamada de Funções}

Por fim, basta elaborar sobre as regras de chamada de função. Usando as funções salvas no ambiente global, uma chamada de $f(\bar e)$ quando $f \in F$ computa a função de nome $f$ do programa. A avaliação dos componentes da função é \emph{eager}, ou seja, primeiro avaliam-se completamente os argumentos em ordem passados a função para depois computar o corpo desta. Essa avaliação é definida pelas regras \hyperref[rule:callfunc-s(j,0)]{(CALLFUNC-S(J,0))} e \hyperref[rule:callfunc-s(j,i)]{(CALLFUNC-S(J,I))}. Essas regras, diferentes das demais, não são exaustivas, mas apenas representam a avaliação do elemento de índice 0 de uma função com $j$ argumentos e a avaliação do argumento de índice $i$ de uma função com $j$ argumentos respectivamente. Elas demonstram que para avaliar um argumento de índice $i$ em uma função com $j$ argumentos, é necessário ter avaliado os argumentos de 0 até $i$ anteriormente.

Com todos os argumentos avaliados, realiza-se a regra \hyperref[rule:callfunc]{(CALLFUNC)}. Nela, obtém-se os nomes dos argumentos da função $f$ assim como o seu corpo $e$, declarando-os dentro da expressão $\KW{Fpop}$ e num escopo $\{\}$. A atribuição dos valores dos argumentos ao nome das respectivas posições é feito usando os operadores de $\KW{let}$ para criar o espaço para os nomes na pilha dentro da função e de $:=$ para atribuir os valores aos nomes dentro da função. Essa forma de realizar a passagem de parâmetros simplifica a semântica da linguagem, fazendo construtos serem dependentes de outros construtos da linguagem, sem criar novos sem necessidade, mas também é capaz de realizar funções recursivas sem nenhum problema.

\labelRule{\label{rule:callfunc-s(j,0)}}{
	\infrule[CallFunc-s(j,0)]
		{F \vdash \St{e_0,a, p, m} \to \St{e_0',a', p', m'}}
		{F \vdash \St{f(e_0, e_{1..j}), a, p, m} \to \St{f(e_0', e_{1..j}), a, p, m}} 
}

\labelRule{\label{rule:callfunc-s(j,i)}}{
	\infrule[CallFunc-s(j,i)]
		{F \vdash \St{e_i,a, p, m} \to \St{e_i',a', p', m'}}
		{F \vdash \St{f(v_{0..i}, e_i, e_{(i + 1)..j}), a, p, m} \to\\ \St{f(v_{0..i}, e_i', e_{(i + 1)..j}), a', p', m'}}
}

\labelRule{\label{rule:callfunc}}{
	\infrule[CallFunc]
		{F(f) = \St{[\overline{x_i}], e}}
		{F \vdash \St{f(\overline{v_i}), a, p, m} \to \\\St{\mathbf{Fpop}\,\{\ \overline{\mathbf{let}\;x_i[1]; x_i := v_i;} e\}, (STOP : a, g), \mathbf{func} : p, m}} 
}
\labelRule{\label{rule:fpop-s}}{
	\infrule[Fpop-s]
		{F \vdash \St{e,a, p, m} \to \St{e',a', p', m'}}
		{F \vdash \St{\mathbf{Fpop}\;e,a, p, m} \to \St{\mathbf{Fpop}\;e',a', p', m'}} 
}

\labelRule{\label{rule:fpop}}{
	\infrule[Fpop]
		{\mathbf{pop}_{func}(p) = p'}
		{F \vdash \St{\mathbf{Fpop}\; v, (h : a, g), p, m} \to \St{v, (a, g), p', m}} 
}

A palavra-chave $\KW{Fpop}$ empilhada é utilizada no ambiente de nomes $a$, como descrito em \ref{sec:pcl-back:semantica:globals}. A regra \hyperref[rule:callfunc]{(CALLFUNC)} adiciona $STOP$ no ambiente de nomes locais $a_l$ e cabe a regra final de $\KW{Fpop}$ \hyperref[rule:fpop]{(FPOP)} remover esse elemento do topo.

%	3.4 Error detection
\section{Detecção de Falhas}
\label{sec:pcl-back:errors}

Em várias regras descritas na seção anterior (\ref{sec:pcl-back:semantica}) há a geração da expressão $\KW{panic}$ seguida de algum código de erro dado algumas pré-condições. Nesta sessão será discorrido o porquê desses erros e quais mecanismos usados. 


A detecção de falhas é completamente associada as regras que acessam memória, ou seja, as regras das seções \ref{sec:pcl-back:semantica:atribui}, \ref{sec:pcl-back:semantica:mem-func} e \ref{sec:pcl-back:semantica:acessa}. A detecção parte dos metadados associados aos locais $l\{i, k, o, s\}$. Inicialmente, valida-se se o acesso à memória está dentro da região delimitada. Para isso, o valor de $o$ do local deve ser igual ou maior que 0 e menor que o seu valor de $s$, da forma $ 0 \le o < s$. Caso contrário, essa é uma falha temporal de \emph{Out-of-Bounds-Read} ou \emph{Out-of-Bounds-Write}, dependendo da regra associada, como em \hyperref[rule:deref-mem-obr]{(DEREF-MEM-OBR)} e \hyperref[rule:atribui-deref-mem-obe]{(ATRIBUI-DEREF-MEM-OBE)} respectivamente. Se o aceso for dentro dos limites, então deve-se validar se a chave $k$ do local $l$ é igual à fechadura $k'$ da célula associada na memória, da forma $k = k'$. Caso contrário, essa é uma falha temporal de \emph{Use-After-Free}, podendo ser de um valor da pilha como em \hyperref[rule:deref-pilha-uaf]{(DEREF-PILHA-UAF)} ou de um valor na memória como em \hyperref[rule:deref-mem-uaf]{(DEREF-MEM-UAF)}.

No contexto de acesso a um valor na memória (\ref{sec:pcl-back:semantica:acessa}) também deve-se validar se o valor acessado é inicializado, da forma $v \neq \bot$. Caso contrário, essa é uma falha de inicialização de \emph{Uninitialized-Access}, como em \hyperref[rule:var-ua]{(VAR-UA)}. Nota-se que em nenhuma regra há a validação de se a célula acessada é não inicializada, ou seja, não se valida se $v \neq -$. Isso se deve ao fato das checagem de falhas serem sequenciais. Só se realiza a operação $v \neq \bot$ após saber que o acesso é a um valor dentro do espaço alocado e esse espaço não foi liberado ainda no momento de acesso. Dessa forma, o espaço foi alocado por uma operação de $\KW{Let}$ ou $\KW{malloc}$ em algum ponto, atribuindo o valor $\bot$ a região e uma operação de limpeza, $\KW{pop}$ e $\KW{free}$, ainda não foi realizada na região, impedindo que o valor pudesse ser redefinido para $-$.

Por fim vale uma atenção especial às falhas detectadas na função $\KW{free}$. No contexto de $PCL_{back}$, a ausência de uma estrutura global para acompanhar as alocações limita a paridade da operação \lstinline[language=C]|free(void*)| de C com o $\KW{free}(l^m, n)$ de $PCL_{back}$. Mesmo assim, vários das falhas descritas em \ref{sec:mem-error:temporal:free} tem paralelos com possíveis falhas de $\KW{free}$ em $PCL_{back}$. Passar o local nulo ou um local com a etiqueta da pilha, são similares a \emph{Free-Memory-Not-On-Heap}, pois em C a pilha e o ponteiro nulo também não são parte da \emph{heap}. Um \emph{Partial-Free} e \emph{Double-Free} não corromperiam a execução de um programa em $PCL_{back}$, porém pode-se usar os metadados de um local $l\{i, k, o, s\}$ para emitir um $\KW{panic}$ quando uma situação que geraria esse tipo de falha em C acontecer em $PCL_{back}$. Para o \emph{Partial-Free}, que acontece na regra \hyperref[rule:free-partial]{(FREE-PARTIAL)}, basta checar que o desvio $o$ é 0 (o local é para o início da região) e o tamanho da região liberada $n$ é igual ao tamanho da região $s$ associada ao local, da forma $s = n$. Escolheu-se, por simplicidade, gerar esse mesmo erro quando se escolhe um $n > s$. Mesmo essa situação não ocorrendo em C, é uma continuação clara dessa falha para $PCL_{back}$. Para o \emph{Double-Free}, que acontece na regra \hyperref[rule:free-double]{(FREE-DOUBLE)}, usa o mesmo mecanismo de detecção de \emph{Use-After-Free} das demais regras, validando se o primeiro elemento tem uma fechadura $k'$ igual à chave $k$ do local que acessa, da forma $k = k'$. Só é necessário fazer a comparação para a chave do primeiro elemento, pois se sabe que a região a ser liberada foi corretamente descrita ($o = 0$ e $s = n$) e não poderia ter sido liberada e realocada parcialmente. Dessa forma, as chaves dessa região são todas as mesmas e fazer a comparação só com a primeira é suficiente.

Uma característica importante dessas regras de detecção de falhas é que elas acabam definindo o que significa uma falha de memória em $PCL_{back}$. No caso de uma falha espacial, se o acesso a pilha ou a memória é via um local $l\{i, k, o, s\}$ com o seu desvio $o$ menor que 0 ou maior ou igual a $s$, então o programa termina de execução e sabe-se que a interrupção foi devido a uma falha espacial. Para as temporais, há mais granularidade. Com \emph{Use-After-Free}, se o acesso a pilha ou a memória é via um local $l\{i, k, o, s\}$ com a sua chave $k$ diferente da fechadura $k'$ do local acessado $i + o$, então o programa termina de execução e sabe-se que a interrupção foi devido a uma falha temporal de tipo \emph{Use-After-Free}. Essas relações podem ser observadas na tabela \ref{table:invariants}, em que os símbolos usados na coluna dos invariantes seriam os símbolos disponíveis no momento da falha correspondente.

\begin{table}[ht]
	\centering
	\caption{Invariantes do Programa}
	\label{table:invariants}
	\begin{tabular}{lll}
		\toprule 
		Tipo & Falha & Invariantes \\
		\midrule
		Espacial	& \emph{Out-of-Bounds-Read} & $0 > o \ge s$ \\
		 			& \emph{Out-of-Bounds-Write} & $0 > o \ge s$ \\
		Temporal 	& \emph{Use-After-Free} & $0 \le o < s \quad k \neq k'$\\
		 			& \emph{Free-Memory-Not-on-Heap} & $l = l^p \lor i = 0$ \\
		 			& \emph{Partil-Free} & $o \neq 0 \lor s \neq n$ \\
		 			& \emph{Double-Free} & $o = 0 \quad s = n \quad k \neq k'$ \\
		Inicialização 	& \emph{Uninitialized-Access} & $0 \le o < s \quad k = k' \quad v = \bot$  \\
		Extra 	    & \emph{Nullptr-Deref} & $i = 0 \quad k = 0 \quad o = 0 \quad s = 0$  \\
		\bottomrule
	\end{tabular}
	\legend{Fonte: O Autor}
\end{table}




\todo[inline]{Adicionar exemplo em PCL-back reproduzindo os erros em C.}

% falar das seções 
% - Declarações e atribuições
% - Funções de memória
% - Acesso a Valores


% In order to detect these kinds of errors, the metadata attached to the pointers 
% needs to uphold certain invariants.$\bullet$ If the offset $o$ of a pointer is 
% bellow 0 or equal or greater than its size $s$ ($0 > o \ge s$), then it results 
% in a \textit{Out of Bounds Read}, such as in (VAR-OBR), which is a Spacial Safety bug.
% $\bullet$ If it is within bounds, but the key $k$ in the pointer does not match 
% the lock $k'$ at the position ($k \neq k'$), then it results in a \textit{Use After Free}, such as in (VAR-UAF), which is a Temporal Safety bug. $\bullet$ With all that, if the value at position is $\bot$, then it results in a \textit{Uninitialized Access}, 
% which is a Initialization safety bug.

% There are a few other errors in the language that were omitted for space, 
% but all of them follow the same principle. This way of approaching errors 
% ends up defining them by the upholding of these invariants. 
% A \textit{Use After Free} error is defined by an access where $k \neq k'$,
% and a case of \textit{Use After Free} only indicates that $k \neq k'$,
% showing that $\mathbf{UseAfterFree} \leftrightarrow k \neq k'$.

