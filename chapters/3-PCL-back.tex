% 3. PCL back
\chapter{PCL-back}

% This work introduces $PCL_{back}$, a C-like core language de-
% signed to detect memory safety violations and to classify
% them. It is designed to be simple, for ease of developing
% proofs, but expressive enough to express common memory
% errors in C. Its syntax is defined as such:

Tendo em vista as falhas de memória descritas na seção \ref{sec:mem-error}, e visando analisá-las mais profundamente e prová-las, é necessário desenvolver uma linguagem alvo para atingir o projeto de prova via compilação. A meta desse projeto é ter uma base relativamente agnóstica a solução a ser provada. Assim, este trabalho introduz $PCL_{back}$, uma linguagem núcleo similar a C desenvolvida para detectar violações de segurança de memória e classificá-las. Ela é definida por sintaxe e semântica operacional \emph{small-step}. 

A escolha de C como base serviu para englobar todos as falhas de memórias, visto que C é uma linguagem que permite acesso e manipulação (quase) irrestrita à memória. Ou seja, C consegue expressar todas as falhas na seção 2.3 \ref{sec:mem-error}. Essa é uma razão bem circular, as falhas são comuns em C porque este permite acesso brando a memória, assim elas são descritas e a linguagem que melhor reproduz elas é C, pois tem acesso \emph{laissez-faire} a memória.

%	3.1 Syntax
\section{Sintaxe}

A sintaxe baseada em C também se demonstrou familiar e facilitou a compreensão dos problemas e exemplos. Adicionalmente, esta é uma linguagem de expressões, permitindo certos padrões funcionais. Mesmo destoando de C, essa caracteristica emergiu acidentalmente da implementação de funções na linguagem. Segue a sintaxe da linguagem:

\begingroup
\setlength{\jot}{-0.2ex} 
	\begin{align*}
		Locals \ni l ::&= l^m \OR l^p &&\\ 
		Value \ni v ::&= n \OR l && \\
		BinOp \ni op ::&= + | - | * | < | > | = | \land | \lor \\
		Expression \ni e ::&= x \OR v \\
		&\NLOR e\; op\; e \OR !e  \\
		&\NLOR \text{*}e \OR \&x \\
		&\NLOR e;e \; \OR \{\,e\,\} \; \\ 
		&\NLOR \mathbf{malloc}(e) \OR \mathbf{free}(e, e) \; \\ 
		&\NLOR \mathbf{let}\; x[n] \OR e := e \; \\
		&\NLOR \mathbf{if}(e) \; e \; \mathbf{else} \; e \; \OR \mathbf{while}(e) \; e \\
		&\NLOR f(\bar e) \\ 
		&\NLOR \mathbf{panic}\;pcode \\ 
		PanicCodes \ni pcode ::&= \mathbf{OutOfBoundsRead}\\
		&\NLOR \mathbf{OutOfBoundsWrite}\\
		&\NLOR \mathbf{NullPtrDereference}\\
		&\NLOR \mathbf{UserError}\\
		&\NLOR \mathbf{UseAfterFree}\\
		&\NLOR \mathbf{UninitializedAcess}\\
		&\NLOR \mathbf{FreeMemoryNotOnHeap}\\
		&\NLOR \mathbf{PartialFree}\\
		&\NLOR \mathbf{DoubleFree}\\
		Function \ni F ::&= \mathbf{let} \; f(\overline{x})\; e \; F \; | \; \mathbf{let}\;() \; e \\
		Globals \ni G ::&= \mathbf{global}\; x[n] \;G \;|\; F
	\end{align*}
\endgroup

\noindent Na sintaxe, o termo $x$ cobre todos os possíveis nomes de variáveis em um programa. 
$f$ cobre todos os nomes de funções. O conjunto $PanicCodes$ são so tipos de falhas de memória, que podem ser divididos nas 5 classes (mais extras) da seguinte forma:
\begin{enumerate}
	\item $\mathbf{OutofBoundsRead}$ e $\mathbf{OutofBoundsWrite}$ são falhas espaciais \ref{sec:mem-error:spacial}, sendo leitura e escrita para além dos limites do \emph{buffer} respectivamente.
	\item $\mathbf{UseAfterFree}$, $\mathbf{FreeMemoryNotOnHeap}$, $\mathbf{Partial ree}$ e $\mathbf{Double Free}$ são falhas temporais \ref{sec:mem-error:temporal}, sendo uso de uma região liberada de memória para o primeiro e corrupção da estrutura alocadora por diversos meios para os demais.
	\item $\mathbf{UninitializedAccess}$ é uma falha de inicialização \ref{sec:mem-error:init}, sendo o acesso ao valor alocado, mas não inicializado. 
	\item $\mathbf{NullPtrDereference}$ é uma falha específica ao domínio de C, em que essa linguagem se baseia \ref{sec:mem-error:temporal:null}, sendo o acesso ao ponteiro nulo.
	\item $\mathbf{UserError}$ é uma interrupção manual de usuário, similar a \lstinline[language=C]|exit(1)| em C. É usado como mecanismo de emissão de erros controlados que terminam a execução.
\end{enumerate}

\noindent Acima há a omissão das falhas de tipos, pois $PCL_{back}$ não é tipada, e os seus valores, locais $l$ e número $n$, encaixam, independente do tamanho, em uma célula. Há também omissão das falhas de condição de corrida. Elas não são representáveis nessa linguagem, pois não possui mecanismos de paralelização.

Esses códigos de pânico $pcode$ servem como interrupções na avaliação da linguagem, indicando uma falha de memória. Eles são um importante componente no processo de compilação e prova. Um método de segurança de memória não precisa ser compreensivo e cobrir todas as falhas geradas, mas se a sua compilação para $PCL_{back}$ não gerar o conjunto de $PanicCodes$ que almeja-se evitar, então afirma-se que o método é correto no que se propõem. Ou seja, dado um processo de indução estrutural em um $PCL_{back}$ compilado de uma linguagem que deseja evitar falhas espaciais, basta que na derivação nunca atinjam-se as expressões $\KW{panic}\;\KW{OutofBoundsRead}$ e $\KW{panic}\;\mathbf{OutofBoundsWrite}$.

%	3.2 Memory Model
\section{Modelo de Memória}

O layout de memória de um programa em C tem vários componentes\todo{Adicionar citação e um diagrama. Provavelmente retirar do livro de C}: o segmento de texto, que contém o programa em si; a seção de dados, que guarda elementos globais, assim como \emph{strings} literais e outros elementos escritos no código; a pilha e a \emph{heap}. A pilha é o lugar em que variáveis locais são alocadas e chamadas de funções são geridas. Ela realiza alocações de tamanho conhecido em tempo de compilação e libera essa memória no final do escopo da variável associada. A \emph{heap} é o lugar em que alocações dinâmicas são colocadas, seja porque o tamanho ou a duração não são conhecidos em tempo de compilação.

A dinâmica entre alocações manuais, aquelas que acontecem na \emph{heap}, e alocações estáticas, aquelas que acontecem na pilha, é um componente importante na reprodução de \emph{bugs} de memória. Falhas na \emph{heap} tendem a ser mais difíceis de encontrar e lidar, pois o processo de requisitar memória e liberá-la manualmente tende a aumentar a superfície de falhas. 

Com o intuito de modelar essa dinâmica, a memória em $PCL_{back}$ usa dois ambientes disjuntos, $p$ para modelar a pilha e $m$ para modelar a \emph{heap}, que, com o intuito de diminuir os estrangeirismos, poderá ser referida como memória a partir deste ponto. 

\subsection{Ponteiros}
\label{sec:pcl-back:ptr}

Com essa distinção, pode-se notar que o elemento da sintaxe responsável por indexar a memória, a localização $l$, é divida em $l^p$ e $l^m$. Nesse contexto, $p$ e $m$ são etiquetas de $l$ que indicam se essa localização é para a pilha ou para memória. Essas localizações também possuem outros metadados, utilizados na avaliação da linguagem para detectar as falhas. Assim, a representação interna dos locais pode ser escrita como:
\[ l^p\{i, k, o, s \} \quad\quad l^m\{i, k, o, s \} \]

Nela, $i$ é o índice de acesso à memória; $k$ é a uma chave única, gerada através da função $\mathbf{newkey}$, que serve para validar os acessos quanto a falhas temporais; $o$ é o \emph{offset} (desvio) do índice base $i$, que recebe o valor das somas e subtrações, ao invés de alterar o índice diretamente; e $s$ é o tamanho da região alocada na memória, que serve para validar os acessos quanto a falhas espaciais. Esses metadados não são acessíveis na escrita do código, mas na semântica operacional tem seus valores internos expostos à avaliação usando a anotação de chaves acima.

\subsection{Pilha}

A pilha é uma lista de elementos, que podem ser valores $v \in \{l, n, \bot, -\}$ ou códigos de controle $c_{ctrl} \in \{\mathbf{stack},\mathbf{func}\}$. Dentre os valores, $l$ e $n$ são os elementos de locais e números da sintaxe da linguagem. $\bot$ e $-$, assim como em \citet{WESSEL2019}, são elementos utilizados na representação da inicialização de um valor, representando um espaço alocado, mas ainda não inicializado, e um espaço não alocado, respectivamente. 

Junto desses elementos guarda-se uma fechadura $k \in \mathbb{N}\text{*}$. Esse elemento serve para a checagem de falhas temporais, similar ao sistema de \emph{key-lock} \ref{sec:mem-error:KeyLock}. Para um acesso ser válido, é necessário que a chave $k$ do local $l$ que tenta acessar a célula seja igual à fechadura $k'$ salva junto ao valor na célula. Valor de controle, junto do $\bot$ e $-$ sempre são empilhados com a chave de valor 0 associada. Uma pilha $p$ da linguagem pode ser definida como uma lista de pares, com o primeiro elemento sendo ou um valor, ou um código de controle, e com o segundo elemento sendo a fechadura de acesso, tal como $p := [(v\,|\,c_{ctrl}, k)]$.

Os códigos de controle citados existem para essa lista se comportar como um pilha de um sistema. Quando se inicia um escopo, coloca-se no fim da lista um código de controle. Chegando no final desse escopo, removem-se elementos do final da lista até atingir o código escolhido, emulando a impermanência dos elementos de uma pilha. Na semântica, utiliza-se das funções $\mathbf{pop}_{stack}(p)$ e $\mathbf{pop}_{func}(p)$ para descrever a ação de remover os elementos da lista até o código de controle $\mathbf{stack}$ ou $\mathbf{func}$. Elas são definidas da seguinte forma:

\begin{figure}[ht]
	\begin{align}
		&\mathbf{pop}_{stack}(p) = \mathbf{pop}(p, stack) \label{fig:def:pop1}\\
		&\mathbf{pop}_{func}(p) = \mathbf{pop}(p, func) \label{fig:def:pop2}\\
		&\mathbf{pop}((v, \_) : t, c_{ctrl}) = \mathbf{if} \; v \neq c_{ctrl} \;\mathbf{then} \; \mathbf{pop}(t, c_{ctrl}) \; \mathbf{else} \; t  \label{fig:def:pop3}\\
		&\mathbf{pop}([], c_{ctrl}) =  [] \label{fig:def:pop4}
	\end{align}
	\caption{Função que define a operação $\mathbf{pop}$}
	\label{fig:def:pop}
\end{figure}

A notação para descrever as funções neste projeto é similar a Haskell \cite{HASKELL}, com casamento de padrões nos argumentos das funções e as definições recursivas. Para o caso acima, em \ref{fig:def:pop1} e \ref{fig:def:pop2} definem as funções $\mathbf{pop}_{stack}(p)$ e $\mathbf{pop}_{func}(p)$ com base na função $\mathbf{pop}(p, v)$, usando como valor inicial de $v$ os seus elementos subscritos. Em \ref{fig:def:pop3} e \ref{fig:def:pop4} realiza a lógica. Se os argumentos casarem o padrão $h : t$, que nesse contexto é a lista poder ser dividida entre o elemento no fim $(v, \_)$ e no restante $t$, então executa-se \ref{fig:def:pop3}. Se a lista for vazia, representada por $[]$, realiza-se \ref{fig:def:pop4}. $(v,\_)$ também é um casamento de padrão, que atribui o nome $v$ para o primeiro elemento da dupla, o valor, e descarta o segundo, a chave. Com esses elementos, \ref{fig:def:pop3} checa se o valor no fim da lista é igual ao código de controle $c_{ctrl}$, se é retorna o restante da lista $t$, se não chama $\mathbf{pop}(t, c_{ctr})$ recursivamente para o restante da lista. Isso descarta elementos do topo da lista até finalmente descartar o $c_{ctrl}$ ou, pela definição \ref{fig:def:pop4}, chegar no final e retorna a lista vazia.

Outras funções similares existem para descrever o acesso, inserção de elementos e edição de elementos na pilha. A inserção no topo da pilha, tal qual em Haskell, utiliza-se o símbolo $:$ como uma operação binária de valor e pilha para pilha. Escreve-se $v : p$ para realizar o empilhamento de $v$ em $p$, retornando $p'$ com $v$ no topo. Caso se deseje empilhar várias cópias de um elemento na pilha, subscreve-se este com um número indicando a quantidade. Dessa forma, escrever $\bot_n : p$ empilha $n$ vezes o valor $\bot$ no topo da pilha. 

O acesso a pilha $p$ na posição $i$, $p(i)$ é descrito pela função:

\begin{figure}[ht]
	\begin{align}
	&p(i) = \mathbf{get}(i, \mathbf{top}(p) - 1, p) \label{fig:def:px1}\\
	&\mathbf{get}(i, size, p_v : p_r) = \mathbf{if}\;i = size \;\mathbf{then}\;p_v\;\mathbf{else}\;\mathbf{get}(i, size - 1, p_r) \label{fig:def:px2}\\
	&\mathbf{get}(\_, \_, []) = (-,0) \label{fig:def:px3}
	\end{align}
	\caption{Função que define a operação de acesso $p(i)$.}
	\label{fig:def:px}
\end{figure}

A notação é similar a \ref{fig:def:pop}, usando a primeira expressão, \ref{fig:def:px1}, para chamar uma função auxiliar associada, neste caso $\mathbf{get(i, size, p)}$ com o índice de acesso $i$, o tamanho atual da pilha $size$ e a pilha $p$ em sí. \ref{fig:def:px1} checa se o índice é igual ao tamanho $size$, se sim retorna o fim da lista, ou seja, o topo da pilha, se não repete recursivamente para o restante da lista, com o $size - 1$. Isso se repete até $i = size$ ou, em \ref{fig:def:px3}, chegar no fim da pilha, retornando $(-,0)$, que representa o valor não inicializado.

A função auxiliar $\mathbf{top}(p)$ utilizada em \ref{fig:def:px1} retorna o tamanho da lista. Esse tamanho também pode ser interpretado como índice para o elemento acima do último elemento da lista. Esse fato é usado na notação da semântica operacional para gerar o índice das alocações na pilha \todo{Referir-se a regra let.}. Uma definição com a notação atual pode ser escrita como:

\begin{figure}[ht]
	\begin{align}
	&\mathbf{top}(\_ : t) = 1 + \mathbf{top}(t) \label{fig:def:top1}\\
	&\mathbf{top}([]) = 0 \label{fig:def:top2}
	\end{align}
	\caption{Função que calcula o tamanho da pilha $p$.}
	\label{fig:def:top}
\end{figure}

Essa é a definição clássica de calcular o tamanho de uma lista recursivamente. Adicionando 1 ao resultado até o final da lista, que retorna 0 para a conta.

Para inserir um valor $v$ na posição $i$ da pilha $p$, escreve-se $p[i \mapsto v]$. Essa operação retorna uma nova pilha $p'$ com o valor atualizado na posição. Ela é melhor visualizada como a operação de indexação e atribuição a um \emph{buffer} em C, da forma \lstinline[language=C]|p[i] = v|. Mas ao quesito de rigorosidade, também se define no estilo funcional da seguinte forma:

\begin{figure}[ht]
	\begin{align}
	&p[i \mapsto v] = \mathbf{set}(i, \mathbf{top}(p) - 1, v) \label{fig:def:set1}\\
	&\mathbf{set}(i, size, (v_p, k_p) : p_r) = \\
	&\quad\quad\mathbf{if}\;i = size \;\mathbf{then}\;(v, k_p) : p_r\;\mathbf{else}\;(v_p, k_p) : \mathbf{set}(i, size - 1, p_r) \label{fig:def:set2}\\
	&\mathbf{get}(\_, \_, []) = [] \label{fig:def:set3}
	\end{align}
	\caption{Função que insere o valor $v$ na posição $i$ da pilha $p$.}
	\label{fig:def:set}
\end{figure}

Ela usa a notação de empilhamento ($:$) com toda a sua expressividade. Após em \ref{fig:def:set1} definir via uma função auxiliar a operação, \ref{fig:def:set2} checa se $i = size$, se for troca o topo da lista atual para uma dupla com a chave anterior e o novo valor. Se $i \neq size$, concatena o topo atual da pilha com o restante da operação. Isso resulta em uma pilha nova final $p'$ cujo único elemento diferente é o da posição de índice $i$. Caso o índice seja para fora da pilha, eventualmente \ref{fig:def:set3} será atingido, terminando a execução e retornando a pilha inalterada.

Uma notação alternativa, para quando se precisa alterar várias posições na pilha para um mesmo valor é $p[i_{m..n} \mapsto v]$. Similarmente a empilhar vários elementos do mesmo valor, essa definição altera os valores da posição $i + m$ até a posição $i + n - 1$ para o valor $v$.


% The values $\bot$ and $-$ are used to detect initialization errors, meaning 
% uninitialized and not allocated respectively, such as in \citet{WESSEL2019}. 
% Every element of the stack is paired with a lock, which is use for temporal errors.
% That results in the \textit{stack} being defined as $p := [(v\,|\,c_{ctrl}, lock)]$.

% The \textit{stack} is indexable, with 0 being the base. $\mathbf{top}(p)$ is 
% the size of the \textit{stack} $p$, which is also the index of the top element~+~1.
% Indexing with $i \ge \mathbf{top}(p)$, results in $(-,0)$. 
% To denote the assignment of a value $v$ to a position $i$ in the stack $p$,
% one writes $p[i \mapsto v]$.

% For the sake of notation, both the \textit{stack} and \textit{heap} can be
% treated as lists from Haskell\cite{HASKELL}.

\subsection{Heap}

% The \textit{heap} is similar to the \textit{stack}, but without the control codes. 
% Therefore a heap $m$ is defined as $m := [(v,lock)]$. In $PCL_{back}$, the heap is 
% manually deallocated with $\mathbf{free}$ and allocated with $\mathbf{malloc}$. 
% This last one uses a helper function $\mathbf{loc}(m,n)$ to find the in $m$, $n$ 
% contiguous unallocated memory cells, returning the starting index of the region.

%	3.3 Operational Semantics
\section{Semântica Operacional}

% The language is defined by means of structural operational semantics, 
% which specifies a one-step relation between configurations (states). 
% One writes $F \vdash \St{e, a, p, m} \to \St{e', a', p', m'}$ to describe 
% the transition of state $\St{e, a, p, m}$ towards state $\St{e', a', p', m'}$ 
% under a global function definition environment $F$. 
% Within the state, $e$ is the program, $a$ is the names environment, 
% $p$ is the stack and $m$ is the heap. 

\todo[inline]{Dar uma formatada mais legal nessas regras que esta meio feio}

\infrule[Compose-s]
    {F \vdash \St{e_1,a, p, m} \to \St{e_1',a', p', m'}}
    {F \vdash \St{e_1;e_2,a, p, m} \to \St{e_1';e_2,a', p', m'}}

\infrule[Compose]
    {}
    {F \vdash \St{v;e, a, p, m} \to \St{e, a, p, m}}
\infrule[Escopo]
    {}
    {F \vdash \St{\{e\},(a,g), p, m} \to \\ \St{\mathbf{pop}\; e,(\{\} : a, g),stack : p, m}}
\infrule[Pop-s]
    {F \vdash \St{e,a, p, m} \to \St{e',a', p', m'}}
    {F \vdash \St{\mathbf{pop}\;e,a, p, m} \to \St{\mathbf{pop}\;e',a', p', m'}} 
 \infrule[Pop]
    {\mathbf{pop}_{stack}(p) = p'}
    {F \vdash \St{\mathbf{pop}\;v,(frame : a, g), p, m} \to\\\St{v,(a, g), p', m}}

\infrule[Let]
    {\mathbf{top}(p) = i \andalso \mathbf{newkey}() = k \andalso l = l^p\{i, k, 0, n\}}
    {F \vdash \St{\mathbf{let}\; x[n],(fr : a, g), p, m} \to\\ \St{l, (fr[x \mapsto l] : a, g),(\bot, k)_n : p, m}} 

\infrule[Atribui-deref-ls]
    {F \vdash \St{e_1,a, p, m} \to \St{e_1', a', p', m'}}
    {F \vdash \St{\text{*}e_1 := e_2, a, p, m} \to \St{\text{*}e_1' := e_2, a', p', m'}} 

\infrule[Atribui-var-rs]
    {F \vdash \St{e, a, p, m} \to \St{e', a', p', m'}}
    {F \vdash \St{x := e, a, p, m} \to \St{x := e', a', p', m'}} 

\infrule[Atribui-deref-rs]
    {F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
    {F \vdash \St{\text{*}l := e, a, p, m} \to \St{\text{*}l := e', a', p', m'}} 

\infrule[Atribui-var-obe]
    {a(x) = l^p\{i, k, o, s\} \andalso 0 > o \ge s}
    {F \vdash \St{x := v, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsWrite}, a, p, m}}
    
\infrule[Atribui-var-uaf]
    {a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\andalso p(i + o) = (v_p, k_p) \andalso k \neq k_p }
    {F \vdash \St{x := v, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}}

\infrule[Atribui-var]
    {a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p }
    {F \vdash \St{x := v, a, p, m} \to \St{v, a, p[i + o \mapsto v], m}} 

\infrule[Atribui-deref-pilha-obe]
    {0 > o \ge s}
    {F\vdash\St{\text{*}l^p\{i, k, o, s\} := v, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsWrite}, a, p, m}} 

\infrule[Atribui-deref-pilha-uaf]
    {0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k \neq k_p }
    {F\vdash\St{\text{*}l^p\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}} 
    
\infrule[Atribui-deref-pilha]
    {0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p }
    {F\vdash\St{\text{*}l^p\{i, k, o, s\} := v, a, p, m} \to\\ \St{v, a, p[i + o \mapsto v], m}} 

\infrule[Atribui-deref-mem-npd]
    {i = 0}
    {F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{NullPtrDeref}, a, p, m}} 

\infrule[Atribui-deref-mem-obe]
    {i \neq 0 \quad 0 > o \ge s}
    {F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsWrite}, a, p, m}} 

\infrule[Atribui-deref-mem-uaf]
    {i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k \neq k_m }
    {F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}} 
    
\infrule[Atribui-deref-mem]
    {i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k = k_m }
    {F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to \\\St{v, a, p, m[i + o \mapsto v]}}

\infrule[Malloc-s]
    {F\vdash\St{e, a, p, m} \to\St{e', a', p', m'}}
    {F\vdash\St{\mathbf{malloc}(e),a, p, m} \to\St{\mathbf{malloc}(e'),a', p', m'}}
    
\infrule[Malloc]
    {\mathbf{loc}(m, n) = i \quad \mathbf{newkey}() = k \quad l = l^m\{i, k, 0, n\}}
    {F\vdash\St{\mathbf{malloc}(n),a, p, m} \to\St{l, a, p, m[i_{0..n} \mapsto (\bot,k)]}} 
    
\infrule[Free-ls]
    {F\vdash\St{e_1, a, p, m} \to\St{e_1', a', p', m'}}
    {F\vdash\St{\mathbf{free}(e_1, e_2),a, p, m} \to\St{\mathbf{free}(e_1', e_2),a', p', m'}}
    
\infrule[Free-rs]
    {F\vdash\St{e, a, p, m} \to\St{e', a', p', m'}}
    {F\vdash\St{\mathbf{free}(l, e),a, p, m} \to\St{\mathbf{free}(l, e'),a', p', m'}} 

\infrule[Free-mnh]
    {}
    {F\vdash\St{\mathbf{free}(l^p, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{FreeMemoryNotOnHeap},a, p, m}}

\infrule[Free-memory-null] 
    {i = 0}
    {F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{FreeMemoryNotOnHeap},a, p, m}}
    
\infrule[Free-pf] 
    {i \neq 0 \quad o \neq 0 \lor s \neq n}
    {F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{PartialFree},a, p, m}}
    
\infrule[Free-df]
    {i \neq 0 \quad o = 0 \quad s = n \quad m(i) = (v_m, k_m) \quad k \neq k_m}
    {F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{DoubleFree},a, p, m}}

\infrule[Free]
    {i \neq 0 \quad o = 0 \quad s = n \quad m(i) = (v_m, k_m) \quad k = k_m}
    {F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\St{n,a, p, m[i_{0..n} \mapsto (-,0)]}}

\infrule[BinOp-ls]
    {F \vdash \St{e_1,a, p, m} \to \St{e_1', a', p', m'}}
    {F \vdash \St{e_1 \;op\; e_2, a, p, m} \to \St{e_1' \;op\; e_2, a', p', m'}} 

\infrule[BinOp-rs]
    {F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
    {F \vdash \St{v \;op\; e, a, p, m} \to \St{v \;op\; e', a', p', m'}}

\infrule[BinOp]
    {\mathbf{binop}(op, v_1, v_2) = v'}
    {F \vdash \St{v_1 \;op\; v_2, a, p, m} \to \St{v', a, p, m}}

\infrule[Not-s]
    {F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
    {F \vdash \St{!e, a, p, m} \to \St{!e', a', p', m'}}

\infrule[Not]
    {\mathbf{not}(v) = n}
    {F \vdash \St{!v, a, p, m} \to \St{n, a, p, m}}

\infrule[Var-obr]
    {a(x) = l^p\{i, k, o, s\} \quad 0 > o \ge s}
    {F \vdash \St{x, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsRead}, a, p, m}}
    
\infrule[Var-uaf]
    {a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k \neq k_p}
    {F \vdash \St{x, a, p, m} \to \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}}

\infrule[Var-ua]
    {a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p = \bot}
    {F \vdash \St{x, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{UninitializedAcess}, a, p, m}} 

\infrule[Var]
    {a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p \neq \bot}
    {F \vdash \St{x, a, p, m} \to \St{v_p, a, p, m}}

\infrule[Ref]
    {a(x) = l^p}
    {F \vdash \St{\&x, a, p, m} \to \St{l^p, a, p, m}}
    
\infrule[Deref-s]
	{F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
	{F \vdash \St{\text{*}e, a, p, m} \to \St{\text{*}e', a', p', m'}} 

\infrule[Deref-pilha-obr]
    {0 > o \ge s}
    {F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsRead}, a, p, m}}
    
\infrule[Deref-pilha-uaf]
    {0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k \neq k_p}
    {F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}} 

\infrule[Deref-pilha-ua]
    {0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p = \bot}
    {F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UninitializedAcess}, a, p, m}}

\infrule[Deref-pilha]
    {0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p \neq \bot}
    {F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to \St{v_p, a, p, m}}

\infrule[Deref-memória-null]
    {i = 0}
    {F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{NullPtrDeref}, a, p, m}}

\infrule[Deref-memória-obr]
    {i \neq 0 \quad 0 > o \ge s}
    {F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsRead}, a, p, m}}
    
\infrule[Deref-memória-uaf]
    {i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k \neq k_m}
    {F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}}

\infrule[Deref-memória-ua]
    {i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k = k_m \quad v_m = \bot}
    {F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UninitializedAcess}, a, p, m}} 
    
\infrule[Deref-memória]
    {i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k = k_m \quad v_m \neq \bot}
    {F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to \St{v_m, a, p, m}}

\infrule[If-s]
    {F \vdash \St{e_1,a, p, m} \to \St{e_1', a', p', m'}}
    {F \vdash \St{\mathbf{if}\;(e_1)\; e_2\; \mathbf{else}\; e_3 ,a, p, m} \to\\ \St{\mathbf{if}\;(e_1')\; e_2\; \mathbf{else}\; e_3 ,a', p', m'}}
    
\infrule[If-true]
    {\mathcal{N}(v) \neq 0}
    {F \vdash \St{\mathbf{if}\;(v)\; e_1\; \mathbf{else}\; e_2 ,a, p, m} \to \St{e_1, a, p, m}} 
\infrule[If-false]
    {\mathcal{N}(v) = 0}
    {F \vdash \St{\mathbf{if}\;(v)\; e_1\; \mathbf{else}\; e_2 ,a, p, m} \to \St{e_2, a, p, m}} 
    
\infrule[While]
    {}
    {F \vdash \St{\mathbf{while}\;(e_1)\; e_2, a, p, m} \to \\ \St{\mathbf{if}\;(e_1)\; (e_2;\mathbf{while}\;(e_1)\; e_2)\; \mathbf{else}\; 0, a, p, m}} 

\infrule[LetFunction-collect]
    {}
    {\St{\mathbf{let} \; f(\overline{x_i})\; e \; F_0 ,F} \to_F \St{F_0, F[f \mapsto \St{[\overline{x_i}], e}]}}

\infrule[Globals-collect]
    {\mathbf{newkey}() = k \quad \mathbf{top}(p) = i}
    {\St{\mathbf{global} \; x[n]\; G , g, p} \to_G\\ \St{G, g[x \mapsto l^p \{i, k, 0, n\}],(\bot, k)_n : p,}} 

\infrule
    {\St{P, \{\}, []} \to_G^* \St{F_0, g, p}\quad\St{F_0, \{\}} \to_F^* \St{\mathbf{let}\;()\;e , F}}
    {F \vdash \St{\{e\}, ([],g),p,[]} \to^* \St{v, ([],g), p, m}} 

%	3.4 Error detection
\section{Detecção de Erros}

% In order to detect these kinds of errors, the metadata attached to the pointers 
% needs to uphold certain invariants.$\bullet$ If the offset $o$ of a pointer is 
% bellow 0 or equal or greater than its size $s$ ($0 > o \ge s$), then it results 
% in a \textit{Out of Bounds Read}, such as in (VAR-OBR), which is a Spacial Safety bug.
% $\bullet$ If it is within bounds, but the key $k$ in the pointer does not match 
% the lock $k'$ at the position ($k \neq k'$), then it results in a \textit{Use After Free}, such as in (VAR-UAF), which is a Temporal Safety bug. $\bullet$ With all that, if the value at position is $\bot$, then it results in a \textit{Uninitialized Access}, 
% which is a Initialization safety bug.

% There are a few other errors in the language that were omitted for space, 
% but all of them follow the same principle. This way of approaching errors 
% ends up defining them by the upholding of these invariants. 
% A \textit{Use After Free} error is defined by an access where $k \neq k'$,
% and a case of \textit{Use After Free} only indicates that $k \neq k'$,
% showing that $\mathbf{UseAfterFree} \leftrightarrow k \neq k'$.

