% 3. PCL back
\chapter{PCL-back}

% This work introduces $PCL_{back}$, a C-like core language de-
% signed to detect memory safety violations and to classify
% them. It is designed to be simple, for ease of developing
% proofs, but expressive enough to express common memory
% errors in C. Its syntax is defined as such:

Tendo em vista as falhas de memória descritas na seção \ref{sec:mem-error}, e visando analisá-las mais profundamente, é necessário desenvolver uma linguagem alvo para o fim de prova via compilação. A meta desse projeto é ter uma base relativamente agnóstica a solução a ser provada. Assim, introduz-se $PCL_{back}$, uma linguagem núcleo similar a C desenvolvida para detectar violações de segurança de memória e classificá-las. Ela é definida por sintaxe e semântica operacional \emph{small-step}. 

A escolha de C como base serviu para englobar todos as falhas de memórias, visto que C é uma linguagem que permite acesso e manipulação (quase) irrestrita à memória. Ou seja, pode-se expressar todas as falhas na seção \ref{sec:mem-error}. Essa é uma razão bem circular, as falhas são comuns em C porque este permite acesso brando a memória e assim elas são descritas; a linguagem que melhor reproduz elas é C, pois tem acesso \emph{laissez-faire} a memória.


%	3.1 Syntax
\section{Sintaxe}

A sintaxe baseada em C também se demonstrou familiar e facilitou a compreensão dos problemas e exemplos. Adicionalmente, esta é uma linguagem de expressões, permitindo certos padrões funcionais. Mesmo destoando de C, essa característica emergiu acidentalmente da implementação de funções na linguagem. A  sintaxe é definida em \ref{fig:pclback:sintax}.
\todo{Adicionar linebreak para fazer o split de das regras em várias páginas?}
\begin{figure*}[ht]
	\begingroup
	%\setlength{\jot}{-0.2ex} 
		\begin{align*}
			Locals \ni l ::&= l^m \OR l^p &&\\ 
			Value \ni v ::&= n \OR l && \\
			BinOp \ni op ::&= + | - | * | < | > | = | \land | \lor \\
			Expression \ni e ::&= x \OR v \\
			&\NLOR e\; op\; e \OR !e  \\
			&\NLOR \text{*}e \OR \&x \\
			&\NLOR e;e \; \OR \{\,e\,\} \OR \KW{pop}\;e\; \\ 
			&\NLOR \mathbf{malloc}(e) \OR \mathbf{free}(e, e) \; \\ 
			&\NLOR \mathbf{let}\; x[n] \OR e := e \; \\
			&\NLOR \mathbf{if}(e) \; e \; \mathbf{else} \; e \; \OR \mathbf{while}(e) \; e \\
			&\NLOR f(\bar e) \OR \KW{Fpop}\;e\\ 
			&\NLOR \mathbf{panic}\;pcode \\ 
			PanicCodes \ni pcode ::&= \mathbf{OutOfBoundsRead}\\
			&\NLOR \mathbf{OutOfBoundsWrite}\\
			&\NLOR \mathbf{NullPtrDereference}\\
			&\NLOR \mathbf{UserError}\\
			&\NLOR \mathbf{UseAfterFree}\\
			&\NLOR \mathbf{UninitializedAcess}\\
			&\NLOR \mathbf{FreeMemoryNotOnHeap}\\
			&\NLOR \mathbf{PartialFree}\\
			&\NLOR \mathbf{DoubleFree}\\
			Function \ni F ::&= \mathbf{let} \; f(\overline{x})\; e \; F \; | \; \mathbf{let}\;() \; e \\
			Globals \ni G ::&= \mathbf{global}\; x[n] \;G \;|\; F
		\end{align*}
	\endgroup
	\caption{Sintaxe de $PCL_{back}$}
	\label{fig:pclback:sintax}
\end{figure*}
% NOTE: funciona, yeyyyyyy
\FloatBarrier

Nela, o termo $x$ cobre todos os possíveis nomes de variáveis em um programa. 
$f$ cobre todos os nomes de funções. O conjunto $PanicCodes$ são so tipos de falhas de memória, que podem ser divididos nas 5 classes (mais extras) da seguinte forma:
\begin{enumerate}
	\item $\mathbf{OutofBoundsRead}$ e $\mathbf{OutofBoundsWrite}$ são falhas espaciais (\ref{sec:mem-error:spacial}), sendo leitura e escrita para além dos limites do \emph{buffer} respectivamente.
	\item $\mathbf{UseAfterFree}$, $\mathbf{FreeMemoryNotOnHeap}$, $\mathbf{Partial ree}$ e $\mathbf{Double Free}$ são falhas temporais (\ref{sec:mem-error:temporal}), sendo uso de uma região liberada de memória para o primeiro e corrupção da estrutura alocadora por diversos meios para os demais.
	\item $\mathbf{UninitializedAccess}$ é uma falha de inicialização (\ref{sec:mem-error:init}), sendo o acesso ao valor alocado, mas não inicializado. 
	\item $\mathbf{NullPtrDereference}$ é uma falha específica ao domínio de C, em que essa linguagem se baseia (\ref{sec:mem-error:temporal:null}), sendo o acesso ao ponteiro nulo.
	\item $\mathbf{UserError}$ é uma interrupção manual de usuário, similar a \lstinline[language=C]|exit(1)| em C. É usado como mecanismo de emissão de erros controlados que terminam a execução.
\end{enumerate}

\noindent Acima há a omissão das falhas de tipos, pois $PCL_{back}$ não é tipado. Os seus valores, locais $l$ e números $n$, encaixam, independente do tamanho, em uma célula. Há também omissão das falhas de condição de corrida. Elas não são representáveis nessa linguagem, pois não possui mecanismos de paralelização.

Esses códigos de pânico $pcode$ servem como interrupções na avaliação da linguagem, indicando uma falha de memória. Eles são um importante componente no processo de compilação e prova. Um método de segurança de memória não precisa ser compreensivo e cobrir todas as falhas geradas, mas se a sua compilação para $PCL_{back}$ não gerar o conjunto de $PanicCodes$ que se almeja evitar, então afirma-se que o método é correto no que se propõem. Ou seja, dado um processo de indução estrutural em um $PCL_{back}$ compilado de uma linguagem que deseja evitar falhas espaciais, basta que na derivação nunca se atinjam as expressões $\KW{panic}\;\KW{OutofBoundsRead}$ e $\KW{panic}\;\mathbf{OutofBoundsWrite}$.

%	3.2 Memory Model
\section{Modelo de Memória}

O layout de memória de um programa em C tem vários componentes\todo{Adicionar citação e um diagrama. Provavelmente retirar do livro de C}: o segmento de texto, que contém o programa em si; a seção de dados, que guarda elementos globais, assim como \emph{strings} literais e outros elementos escritos no código; a pilha e a \emph{heap}. A pilha é o lugar em que variáveis locais são alocadas e chamadas de funções são geridas. Ela realiza alocações de tamanho conhecido em tempo de compilação e libera essa memória no final do escopo da variável associada. A \emph{heap} é o lugar em que alocações dinâmicas são colocadas, seja porque o tamanho ou a duração não são conhecidos em tempo de compilação.

A dinâmica entre alocações manuais, aquelas que acontecem na \emph{heap}, e alocações estáticas, aquelas que acontecem na pilha, é um componente importante na reprodução de \emph{bugs} de memória. Falhas na \emph{heap} tendem a ser mais difíceis de encontrar e lidar, pois o processo de requisitar memória e liberá-la manualmente tende a aumentar a superfície de falhas. 

Com o intuito de modelar essa dinâmica, a memória em $PCL_{back}$ usa dois ambientes disjuntos, $p$ para modelar a pilha e $m$ para modelar a \emph{heap}, que, com o intuito de diminuir os estrangeirismos, poderá ser referida como memória a partir deste ponto. 

\subsection{Ponteiros}
\label{sec:pcl-back:ptr}

Com essa distinção, pode-se notar que o elemento da sintaxe responsável por indexar a memória, a localização $l$, é divida em $l^p$ e $l^m$. Nesse contexto, $p$ e $m$ são etiquetas de $l$ que indicam se essa localização é para a pilha ou para memória. Essas localizações também possuem outros metadados, utilizados na avaliação da linguagem para detectar as falhas. Assim, a representação interna dos locais pode ser escrita como:
\begin{figure*}[ht]
	\begin{align*}
		l^p\{i, k, o, s \} && l^m\{i, k, o, s \}
	\end{align*}
	\caption{Layout dos metadados dos locais.}
	\label{fig:ptr:metada}
\end{figure*}
\todo{Fazer um diagrama mais legal?}

Nela, $i$ é o índice de acesso à memória; $k$ é a uma chave única, gerada através da função $\mathbf{newkey}$, que serve para validar os acessos quanto a falhas temporais; $o$ é o \emph{offset} (desvio) do índice base $i$, que recebe o valor das somas e subtrações, ao invés de alterar o índice diretamente; e $s$ é o tamanho da região alocada na memória, que serve para validar os acessos quanto a falhas espaciais. Esses metadados não são acessíveis na escrita do código, mas na semântica operacional tem seus valores internos expostos à avaliação usando a anotação de chaves acima.

\subsection{Pilha}
\label{sec:pcl-back:pilha}

A pilha é uma lista de elementos, que podem ser valores $v \in \{l, n, \bot, -\}$ ou códigos de controle $c_{ctrl} \in \{\mathbf{stack},\mathbf{func}\}$. Dentre os valores, $l$ e $n$ são os elementos de locais e números da sintaxe da linguagem. $\bot$ e $-$, assim como em \citet{WESSEL2019}, são elementos utilizados na representação da inicialização de um valor, representando um espaço alocado, mas ainda não inicializado, e um espaço não alocado, respectivamente. 

Junto desses elementos guarda-se uma fechadura $k \in \mathbb{N}\text{*}$. Esse elemento serve para a checagem de falhas temporais, similar ao sistema de \emph{key-lock} \ref{sec:mem-error:KeyLock}. Para um acesso ser válido, é necessário que a chave $k$ do local $l$ que tenta acessar a célula seja igual à fechadura $k'$ salva junto ao valor na célula. Valor de controle, junto do $\bot$ e $-$ sempre são empilhados com a chave de valor 0 associada. Uma pilha $p$ da linguagem pode ser definida como uma lista de pares, com o primeiro elemento sendo ou um valor, ou um código de controle, e com o segundo elemento sendo a fechadura de acesso, tal como $p := [(v\,|\,c_{ctrl}, k)]$.

Os códigos de controle citados existem para essa lista se comportar como um pilha de um sistema. Quando se inicia um escopo, coloca-se no fim da lista um código de controle. Chegando no final desse escopo, removem-se elementos do final da lista até atingir o código escolhido, emulando a impermanência dos elementos de uma pilha. Na semântica, utiliza-se das funções $\mathbf{pop}_{stack}(p)$ e $\mathbf{pop}_{func}(p)$ para descrever a ação de remover os elementos da lista até o código de controle $\mathbf{stack}$ ou $\mathbf{func}$. Elas são definidas da seguinte forma:

\begin{figure}[ht]
	\begin{align}
		&\mathbf{pop}_{stack}(p) = \mathbf{pop}(p, stack) \label{fig:def:pop1}\\
		&\mathbf{pop}_{func}(p) = \mathbf{pop}(p, func) \label{fig:def:pop2}\\
		&\mathbf{pop}((v, \_) : t, c_{ctrl}) = \mathbf{if} \; v \neq c_{ctrl} \;\mathbf{then} \; \mathbf{pop}(t, c_{ctrl}) \; \mathbf{else} \; t  \label{fig:def:pop3}\\
		&\mathbf{pop}([], c_{ctrl}) =  [] \label{fig:def:pop4}
	\end{align}
	\caption{Função que define a operação $\mathbf{pop}$}
	\label{fig:def:pop}
\end{figure}

A notação para descrever as funções neste projeto é similar a Haskell \cite{HASKELL}, com casamento de padrões nos argumentos das funções e as definições recursivas. Para o caso acima, em \ref{fig:def:pop1} e \ref{fig:def:pop2} definem as funções $\mathbf{pop}_{stack}(p)$ e $\mathbf{pop}_{func}(p)$ com base na função $\mathbf{pop}(p, v)$, usando como valor inicial de $v$ os seus elementos subscritos. Em \ref{fig:def:pop3} e \ref{fig:def:pop4} realiza a lógica. Se os argumentos casarem o padrão $h : t$, que nesse contexto é a lista poder ser dividida entre o elemento no fim $(v, \_)$ e no restante $t$, então executa-se \ref{fig:def:pop3}. Se a lista for vazia, representada por $[]$, realiza-se \ref{fig:def:pop4}. $(v,\_)$ também é um casamento de padrão, que atribui o nome $v$ para o primeiro elemento da dupla, o valor, e descarta o segundo, a chave. Com esses elementos, \ref{fig:def:pop3} checa se o valor no fim da lista é igual ao código de controle $c_{ctrl}$, se é retorna o restante da lista $t$, se não chama $\mathbf{pop}(t, c_{ctr})$ recursivamente para o restante da lista. Isso descarta elementos do topo da lista até finalmente descartar o $c_{ctrl}$ ou, pela definição \ref{fig:def:pop4}, chegar no final e retorna a lista vazia.

Outras funções similares existem para descrever o acesso, inserção de elementos e edição de elementos na pilha. A inserção no topo da pilha, tal qual em Haskell, utiliza-se o símbolo $:$ como uma operação binária de valor e pilha para pilha. Escreve-se $v : p$ para realizar o empilhamento de $v$ em $p$, retornando $p'$ com $v$ no topo. Caso se deseje empilhar várias cópias de um elemento na pilha, subscreve-se este com um número indicando a quantidade. Dessa forma, escrever $\bot_n : p$ empilha $n$ vezes o valor $\bot$ no topo da pilha. 

O acesso a pilha $p$ na posição $i$, $p(i)$ é descrito pela função:

\begin{figure}[ht]
	\begin{align}
	&p(i) = \mathbf{get}(i, \mathbf{top}(p) - 1, p) \label{fig:def:px1}\\
	&\mathbf{get}(i, size, p_v : p_r) = \mathbf{if}\;i = size \;\mathbf{then}\;p_v\;\mathbf{else}\;\mathbf{get}(i, size - 1, p_r) \label{fig:def:px2}\\
	&\mathbf{get}(\_, \_, []) = (-,0) \label{fig:def:px3}
	\end{align}
	\caption{Função que define a operação de acesso $p(i)$.}
	\label{fig:def:px}
\end{figure}

A notação é similar a \ref{fig:def:pop}, usando a primeira expressão, \ref{fig:def:px1}, para chamar uma função auxiliar associada, neste caso $\mathbf{get(i, size, p)}$ com o índice de acesso $i$, o tamanho atual da pilha $size$ e a pilha $p$ em sí. \ref{fig:def:px1} checa se o índice é igual ao tamanho $size$, se sim retorna o fim da lista, ou seja, o topo da pilha, se não repete recursivamente para o restante da lista, com o $size - 1$. Isso se repete até $i = size$ ou, em \ref{fig:def:px3}, chegar no fim da pilha, retornando $(-,0)$, que representa o valor não inicializado.

A função auxiliar $\mathbf{top}(p)$ utilizada em \ref{fig:def:px1} retorna o tamanho da lista. Esse tamanho também pode ser interpretado como índice para o elemento acima do último elemento da lista. Esse fato é usado na notação da semântica operacional para gerar o índice das alocações na pilha \todo{Referir-se a regra let.}. Uma definição com a notação atual pode ser escrita como:

\begin{figure}[ht]
	\begin{align}
	&\mathbf{top}(\_ : t) = 1 + \mathbf{top}(t) \label{fig:def:top1}\\
	&\mathbf{top}([]) = 0 \label{fig:def:top2}
	\end{align}
	\caption{Função que calcula o tamanho da pilha $p$.}
	\label{fig:def:top}
\end{figure}

Essa é a definição clássica de calcular o tamanho de uma lista recursivamente. Adicionando 1 ao resultado até o final da lista, que retorna 0 para a conta.

Para inserir um valor $v$ na posição $i$ da pilha $p$, escreve-se $p[i \mapsto v]$. Essa operação retorna uma nova pilha $p'$ com o valor atualizado na posição. Ela é melhor visualizada como a operação de indexação e atribuição a um \emph{buffer} em C, da forma \lstinline[language=C]|p[i] = v|. Mas ao quesito de rigorosidade, também se define no estilo funcional da seguinte forma:

\begin{figure}[ht]
	\begin{align}
	&p[i \mapsto v] = \mathbf{set}(i, \mathbf{top}(p) - 1, v) \label{fig:def:set1}\\
	&\mathbf{set}(i, size, (v_p, k_p) : p_r) = \mathbf{if}\;i = size \;\mathbf{then} \nonumber\\ 
	&\quad\quad(v, k_p) : p_r\;\mathbf{else}\;(v_p, k_p) : \mathbf{set}(i, size - 1, p_r) \label{fig:def:set2}\\
	&\mathbf{get}(\_, \_, []) = [] \label{fig:def:set3}
	\end{align}
	\caption{Função que insere o valor $v$ na posição $i$ da pilha $p$.}
	\label{fig:def:set}
\end{figure}

Ela usa a notação de empilhamento ($:$) com toda a sua expressividade. Após em \ref{fig:def:set1} definir via uma função auxiliar a operação, \ref{fig:def:set2} checa se $i = size$, se for troca o topo da lista atual para uma dupla com a chave anterior e o novo valor. Se $i \neq size$, concatena o topo atual da pilha com o restante da operação. Isso resulta em uma pilha nova final $p'$ cujo único elemento diferente é o da posição de índice $i$. Caso o índice seja para fora da pilha, eventualmente \ref{fig:def:set3} será atingido, terminando a execução e retornando a pilha inalterada.

Uma notação alternativa, para quando se precisa alterar várias posições na pilha para um mesmo valor é $p[i_{m..n} \mapsto v]$. Similarmente a empilhar vários elementos do mesmo valor, essa definição altera os valores da posição $i + m$ até a posição $i + n - 1$ para o valor $v$.


\subsection{\emph{Heap}}
\label{sec:pcl-back:mem}

A memória (\emph{heap}) é extremamente similar a pilha, porém sem os códigos de controle. Partindo disso, a memória $m$ é uma lista de pares, valor $v \in \{n, l, \bot, -\}$ fechadura $k \in \mathbb{N}$, podendo ser escrito na forma $m := [(v, k)]$. Essa lista pode ser imaginada infinitamente grande, tendo todas as células inicializadas com o valor $-$.

As células da memória são manualmente liberadas com a função $\mathbf{free}$ e alocadas com a função $\mathbf{malloc}$. Essa última usa uma função auxiliar $mathbf{loc(m,n)}$ para encontrar na memória $m$, $n$ células contíguas não alocadas (com o valor $-$) e retorna o índice do começo dessa região. Ela é descrita mais formalmente da seguinte forma:

\begin{figure}[ht]
	\begin{align}
	&\mathbf{loc}(m,n) = \mathbf{loc}'(m, n, 0, 1) \label{fig:def:loc1}\\
	& \mathbf{loc}'(m, n_0 , n_1, i) = \mathbf{if}\; m(i + n_1) \neq (-,0) \; \mathbf{then}\nonumber \\
	&\quad\mathbf{loc}'(m, n_0, 0, i + n_1 + 1)\; \mathbf{else} \nonumber\\
	&\quad\quad(\mathbf{if}\; n_0 = n_1 \; \mathbf{then}\; i \;\mathbf{else}\; \mathbf{loc}'(m, n_0, n_1 + 1, i)) \label{fig:def:loc2}
	\end{align}
	\caption{Função encontra em $m$, $n$ contíguas células não alocadas.}
	\label{fig:def:loc}
\end{figure}

\noindent Ela primeiro chama uma função auxiliar em \ref{fig:def:loc1}, com 0 para $n_1$, o tamanho atual da região encontrada,  e 1 para $i$, o índice de início de busca. Parte-se do índice de número um, mesmo a indexação da lista iniciando no 0, pois se reserva esse espaço para a implementação do ponteiro nulo. Em \ref{fig:def:loc2} realiza-se a computação: se o valor no índice $i$ da memória $m$ mais o tamanho da região atual encontrada $n_1$ não for o par $(-,0)$ (célula não alocada), então reinicia a busca, partindo no índice seguinte ao analisado nesse teste; se não for o caso, verifica-se se já se encontrou a região do tamanho esperado, se sim, retorna o índice $i$, que é o índice do começo desta, se não, avalia-se a célula seguinte, chamando $\mathbf{loc}'$ recursivamente, incrementando o valor da região encontrada em 1.

Na definição dessa função, utilizou-se a expressão $m(i)$ para indicar o acesso ao elemento de índice $i$ da memória $m$. Assim como o acesso na pilha, essa operação pode ser vista como uma simples indexação a um \emph{buffer}. Neste caso, como há a intuição da memória ser infinita, para qualquer índice $i$ há uma célula correspondente na memória. Como todas elas iniciam com o valor $(-,0)$, o comportamento de acessar para além do espaço alocado é o mesmo de quando isso acontece na pilha. A atribuição segue o mesmo padrão, inserir o valor $v$ no índice $i$ da memória $m$ é escrito como $m[i \mapsto v]$. Aqui omiti-se a definição porque estas são (quase) idênticas às definições da pilha, visto que a memória não pode ser realmente infinita. O mesmo segue para a atribuição de várias células com a notação $m[i_{m..n} \mapsto v]$ cujo comportamento é o mesmo que na pilha, porém no contexto da memória essa função é mais usada, visto que é  instrumental as definições de $\mathbf{malloc}$ e $\mathbf{free}$.


%	3.3 Operational Semantics
\section{Semântica Operacional}

A linguagem $PCL_{back}$ é definida por meios de semântica operacional estrutural, que especifica uma relação de um passo entre configurações (estados). Ela é subdividida em 3 avaliações: a avaliação dos globais, com o fecho transitivo $\to_G$, a avaliação das funções, com o fecho transitivo $\to_F$ e a avaliação das expressões, ou melhor, o programa em si, com o fecho $\to$. Um programa $P$ de $PCL_{front}$ pode ser visto como uma lista de declarações de variáveis globais, seguida de uma lista de declarações de funções globais, seguida da função de entrada do programa, como demonstra \ref{fig:tree-structure}.

\begin{figure*}[ht]
	\centering
	\begin{tikzpicture}[
		squarednode/.style={rectangle, draw=red!60, fill=red!5, very thick, minimum size=5mm},
	]
		%Nodes
		\node (G0) {$\KW{global}\;x[n]\; G$};
		\node (GtoF) [right=of G0] {$\;\KW{global}\;x[n]\; F$};
		\node (F0) [below=of GtoF] {$\KW{let}\;f(\bar x)\;e\;F$};
		\node (FtoE) [right=of F0] {$\;\KW{let}\;()$};
		\node (E) [right=0cm of FtoE] {$e$};
		
		%Lines
		\draw[->] (G0.east) -- (GtoF.west) node[at end, above] () {$*$} node[at end, below] () {G};

		\draw[->] (F0.east) -- (FtoE.west) node[at end, above] () {$*$} node[at end, below] () {F};

		\draw[->] (GtoF.south)  -- (F0.north);

		\node[draw, dotted, fit=(G0) (GtoF) (F0) (FtoE) (E), inner sep=0.1cm, label={[anchor=south east, xshift=12mm]north west:Globais}] {};

		\node[draw, dashed, fit=(F0) (FtoE) (E), inner sep=0.1cm, label={[anchor=south east, xshift=12mm]north west:Funções}] {};

		\node[draw, fit=(E), inner sep=0.1cm, label={[anchor=south east, xshift=12mm]north west:Programa}] {};
	\end{tikzpicture}
	\caption{Árvore de um programa em $PCL_{back}$.}
	\label{fig:tree-structure}
\end{figure*}

Dessa forma, um programa $P$ coleta primeiro todas as globais, depois coleta todas as funções e com essas informações computa o resultado do programa $e$. O asterisco indicado acima dos fechos transitivos indica que $n$ ou mais passos foram tomados até atingir o resultado a direita. O diagrama pode ser mais formalmente descrito como:

\ignoreLtex{
\infrule[Run]
    {\St{P, \{\}, []} \to_G^* \St{F_0, g, p}\quad\St{F_0, \{\}} \to_F^* \St{\mathbf{let}\;()\;e , F}}
    {F \vdash \St{\{e\}, ([],g),p,[]} \to^* \St{v, ([],g), p, m}} 
}
\label{rule:run}
\noindent Dizendo que, para avaliar a expressão $e$ sob um escopo $\{\}$, é necessário primeiro avaliar sequencialmente as globais e as funções, usando essas informações na computação de $e$.

Essa computação de $e$ é o fecho transitivo $\to$, que descreve a transição do estado $\St{e, a, p, m}$ para o estado $\St{e', a', p', m'}$ sob a definição do ambiente global de funções $F$. Isso totaliza a expressão $F \vdash \St{e, a, p, m} \to \St{e', a', p', m'}$. Nesse contexto, $F$ é o ambiente global de funções, $e$ é o programa (expressão) a ser computado, $a$ é o ambiente de nomes, $p$ é a pilha, como descrita em \ref{sec:pcl-back:pilha}, e $m$ é a memória, como descrita em \ref{sec:pcl-back:mem}.

\subsection{Globais}

As globais do programa são declaradas todas juntas no começo do programa. Para isso, define-se o fecho transitivo $\to_G$ da seguinte forma:

\ignoreLtex{
\infrule[Globals-collect]
    {\mathbf{newkey}() = k \quad \mathbf{top}(p) = i}
    {\St{\mathbf{global} \; x[n]\; G , g, p} \to_G\\ \St{G, g[x \mapsto l^p \{i, k, 0, n\}],(\bot, k)_n : p,}} 
}

\noindent Dada a declaração $\KW{global}\;x[n]$, empilha-se no topo da pilha $n$ vezes a dupla $(\bot, k)$ representando $n$ posições alocadas, mas não inicializadas, que só podem ser acessadas com um ponteiro que tenha uma chave de valor $k$. Para associar o nome $x$ a essa posição na pilha, salva o local construído com os metadados gerados no ambiente de nomes globais $g$.

Esse ambiente, $g$, é um mapa de nomes a locais na pilha, podendo ser escrito como $g := Map\;nome\;l^p$. Obter o valor associado a um nome $x$ no mapa $g$, escreve $g(x)$. Essa operação  retorna $-$ quando $x \notin g$. Atribuir um valor no mapa usa a mesma notação das atribuições nos demais ambiente. Para atribuir o local $l^p$ ao nome $x$ no mapa $g$, escreve-se $g[x \mapsto l^p]$. 

A regra (\hyperref[rule:run]{GLOBALS-COLLECT}) executa até que o elemento $G$ sequente seja uma função (\ref{fig:tree-structure}). Ao chegar nesse ponto, a execução está finalizada e o ambiente de nomes globais foi construído e os valores foram empilhados na base da pilha. O ambiente gerado $g$ é apenas um elemento da dupla que compõe o ambiente de nomes na execução do programa. 

A outra parte é o ambiente de nomes locais $a_l$. Este, é uma pilha de mapas, nome - local na pilha, e códigos de controle $STOP$. Esses mapas são definidos exatamente igual ao ambiente global de nomes. O uso do $STOP$ serve para delimitar acessos apenas as variáveis alcançáveis naquele ponto do programa, fazendo $PCL_{back}$ ter um escopo estático. Adicionar elementos no topo de $a_l$ usa a mesma notação de lista usada na pilha. Para encontrar o valor associado com o nome $x$ em $a_l$, realiza-se uma busca nos mapas em ordem até ou chegar a um código de controle $STOP$, ou até chegar na base da pilha. Dessa forma, define-se o acesso ao valor associado a uma variável $x$ no ambiente de nomes completo $a$, que é o par $(a_l, g)$, como $a(x)$, descrito como:

\begin{figure}[ht]
	\begin{align}
		&(map : a_l, g)(x) = \mathbf{if}\; map(x) \neq - \;\mathbf{then}\; map(x) \;\mathbf{else}\; (a_r, g)(x)\label{fig:def:amb:acess1}\\
		&(STOP \;:\;a_l, g)(x) = g(x) \label{fig:def:amb:acess2}\\
		&([], g)(x) = g(x)\label{fig:def:amb:acess3}
	\end{align}
	\caption{Função que obtém o local da pilha em $a$ associado a variável $x$. }
	\label{fig:def:amb:acess}
\end{figure}

Em \ref{fig:def:amb:acess1}, se $x$ existir no mapa no topo de $a_l$, retorna esse valor. Se não, repete para o restante de $a_l$ até encontrar um valor ou parar, via código de controle $STOP$ (\ref{fig:def:amb:acess2}) ou via fim de $a_l$ (\ref{fig:def:amb:acess3}). No caso de parada, obtém-se o valor associado de $x$ no ambiente de nomes globais.

Não há função específica para alterar o valor de um nome $x$ em $a$. Para realizar essa operação, obtém-se o valor no topo da pilha, que é um mapa, e usa-se a notação de atribuição de mapa para esse processo. Isso limita a atribuição em $a$ para apenas o mapa no topo da pilha, ou próximo do topo. Isso não é problema, pois no contexto de $PCL_{back}$, o valor associado a um nome no ambiente não é modificado após a sua inserção inicial, que sempre ocorrerá no topo. A remoção de nomes consiste em desempilhar o topo de $a_l$, casando o padrão e retornando a cauda.

\subsection{Funções}

O passo seguinte, após a avaliação das globais, é o de captura das funções. Para isso, define-se o fecho transitivo $\to_F$ da seguinte forma:

\ignoreLtex{
\infrule[LetFunction-collect]
    {}
    {\St{\mathbf{let} \; f(\overline{x_i})\; e \; F_0 ,F} \to_F \St{F_0, F[f \mapsto \St{[\overline{x_i}], e}]}}
}
\noindent O fecho apenas captura a lista de nomes de argumentos $\bar x_i$ e o corpo da função $e$ e associa eles ao nome $f$ desta no ambiente $F$, tal como $F[f \mapsto \St{[\bar x_i], e}]$. Tanto a notação de atribuição quanto a notação de acesso são iguais ao do ambiente global de nomes $g$, pois $F$ também é um mapa, só que este é um mapa de nomes de funções $f$ para duplas, lista dos nomes dos argumentos - corpo da função, $\St{[\bar x_i], e}$. Ou seja, pode-se definir $F$ com a expressão $F := Map\;f\; \St{[\bar x_i], e}$.

Essa operação de coleta continua até chegar na função principal do programa, escrita como $\KW{let}\;()\; e$. A esse ponto, realiza-se a avaliação do programa sob o ambiente de funções globais $F$ gerado. 

\subsection{Expressões}

A avaliação das expressões começa com um ambiente de funções globais já formado, assim como uma pilha e ambiente de nomes com valores advindos da avaliação das globais. A memória é inicializada vazia, mas como elaborado em \ref{sec:pcl-back:mem}, virtualmente todas as células já possuem o valor $(-, 0)$.

\todo[inline]{falar aqui das transições e tal}

\ignoreLtex{
\infrule[Compose-s]
    {F \vdash \St{e_1,a, p, m} \to \St{e_1',a', p', m'}}
    {F \vdash \St{e_1;e_2,a, p, m} \to \St{e_1';e_2,a', p', m'}}

\infrule[Compose]
    {}
    {F \vdash \St{v;e, a, p, m} \to \St{e, a, p, m}}
\infrule[Escopo]
    {}
    {F \vdash \St{\{e\},(a,g), p, m} \to \\ \St{\mathbf{pop}\; e,(\{\} : a, g),stack : p, m}}
\infrule[Pop-s]
    {F \vdash \St{e,a, p, m} \to \St{e',a', p', m'}}
    {F \vdash \St{\mathbf{pop}\;e,a, p, m} \to \St{\mathbf{pop}\;e',a', p', m'}} 
 \infrule[Pop]
    {\mathbf{pop}_{stack}(p) = p'}
    {F \vdash \St{\mathbf{pop}\;v,(frame : a, g), p, m} \to\\\St{v,(a, g), p', m}}

\infrule[Let]
    {\mathbf{top}(p) = i \andalso \mathbf{newkey}() = k \andalso l = l^p\{i, k, 0, n\}}
    {F \vdash \St{\mathbf{let}\; x[n],(fr : a, g), p, m} \to\\ \St{l, (fr[x \mapsto l] : a, g),(\bot, k)_n : p, m}} 

\infrule[Atribui-deref-ls]
    {F \vdash \St{e_1,a, p, m} \to \St{e_1', a', p', m'}}
    {F \vdash \St{\text{*}e_1 := e_2, a, p, m} \to \St{\text{*}e_1' := e_2, a', p', m'}} 

\infrule[Atribui-var-rs]
    {F \vdash \St{e, a, p, m} \to \St{e', a', p', m'}}
    {F \vdash \St{x := e, a, p, m} \to \St{x := e', a', p', m'}} 

\infrule[Atribui-deref-rs]
    {F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
    {F \vdash \St{\text{*}l := e, a, p, m} \to \St{\text{*}l := e', a', p', m'}} 

\infrule[Atribui-var-obe]
    {a(x) = l^p\{i, k, o, s\} \andalso 0 > o \ge s}
    {F \vdash \St{x := v, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsWrite}, a, p, m}}
    
\infrule[Atribui-var-uaf]
    {a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\andalso p(i + o) = (v_p, k_p) \andalso k \neq k_p }
    {F \vdash \St{x := v, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}}

\infrule[Atribui-var]
    {a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p }
    {F \vdash \St{x := v, a, p, m} \to \St{v, a, p[i + o \mapsto v], m}} 

\infrule[Atribui-deref-pilha-obe]
    {0 > o \ge s}
    {F\vdash\St{\text{*}l^p\{i, k, o, s\} := v, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsWrite}, a, p, m}} 

\infrule[Atribui-deref-pilha-uaf]
    {0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k \neq k_p }
    {F\vdash\St{\text{*}l^p\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}} 
    
\infrule[Atribui-deref-pilha]
    {0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p }
    {F\vdash\St{\text{*}l^p\{i, k, o, s\} := v, a, p, m} \to\\ \St{v, a, p[i + o \mapsto v], m}} 

\infrule[Atribui-deref-mem-npd]
    {i = 0}
    {F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{NullPtrDeref}, a, p, m}} 

\infrule[Atribui-deref-mem-obe]
    {i \neq 0 \quad 0 > o \ge s}
    {F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsWrite}, a, p, m}} 

\infrule[Atribui-deref-mem-uaf]
    {i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k \neq k_m }
    {F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}} 
    
\infrule[Atribui-deref-mem]
    {i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k = k_m }
    {F\vdash\St{\text{*}l^m\{i, k, o, s\} := v, a, p, m} \to \\\St{v, a, p, m[i + o \mapsto v]}}

\infrule[Malloc-s]
    {F\vdash\St{e, a, p, m} \to\St{e', a', p', m'}}
    {F\vdash\St{\mathbf{malloc}(e),a, p, m} \to\St{\mathbf{malloc}(e'),a', p', m'}}
    
\infrule[Malloc]
    {\mathbf{loc}(m, n) = i \quad \mathbf{newkey}() = k \quad l = l^m\{i, k, 0, n\}}
    {F\vdash\St{\mathbf{malloc}(n),a, p, m} \to\St{l, a, p, m[i_{0..n} \mapsto (\bot,k)]}} 
    
\infrule[Free-ls]
    {F\vdash\St{e_1, a, p, m} \to\St{e_1', a', p', m'}}
    {F\vdash\St{\mathbf{free}(e_1, e_2),a, p, m} \to\St{\mathbf{free}(e_1', e_2),a', p', m'}}
    
\infrule[Free-rs]
    {F\vdash\St{e, a, p, m} \to\St{e', a', p', m'}}
    {F\vdash\St{\mathbf{free}(l, e),a, p, m} \to\St{\mathbf{free}(l, e'),a', p', m'}} 

\infrule[Free-mnh]
    {}
    {F\vdash\St{\mathbf{free}(l^p, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{FreeMemoryNotOnHeap},a, p, m}}

\infrule[Free-memory-null] 
    {i = 0}
    {F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{FreeMemoryNotOnHeap},a, p, m}}
    
\infrule[Free-pf] 
    {i \neq 0 \quad o \neq 0 \lor s \neq n}
    {F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{PartialFree},a, p, m}}
    
\infrule[Free-df]
    {i \neq 0 \quad o = 0 \quad s = n \quad m(i) = (v_m, k_m) \quad k \neq k_m}
    {F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{DoubleFree},a, p, m}}

\infrule[Free]
    {i \neq 0 \quad o = 0 \quad s = n \quad m(i) = (v_m, k_m) \quad k = k_m}
    {F\vdash\St{\mathbf{free}(l^m\{i, k, o, s\}, n),a, p, m} \to\St{n,a, p, m[i_{0..n} \mapsto (-,0)]}}

\infrule[BinOp-ls]
    {F \vdash \St{e_1,a, p, m} \to \St{e_1', a', p', m'}}
    {F \vdash \St{e_1 \;op\; e_2, a, p, m} \to \St{e_1' \;op\; e_2, a', p', m'}} 

\infrule[BinOp-rs]
    {F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
    {F \vdash \St{v \;op\; e, a, p, m} \to \St{v \;op\; e', a', p', m'}}

\infrule[BinOp]
    {\mathbf{binop}(op, v_1, v_2) = v'}
    {F \vdash \St{v_1 \;op\; v_2, a, p, m} \to \St{v', a, p, m}}

\infrule[Not-s]
    {F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
    {F \vdash \St{!e, a, p, m} \to \St{!e', a', p', m'}}

\infrule[Not]
    {\mathbf{not}(v) = n}
    {F \vdash \St{!v, a, p, m} \to \St{n, a, p, m}}

\infrule[Var-obr]
    {a(x) = l^p\{i, k, o, s\} \quad 0 > o \ge s}
    {F \vdash \St{x, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsRead}, a, p, m}}
    
\infrule[Var-uaf]
    {a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k \neq k_p}
    {F \vdash \St{x, a, p, m} \to \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}}

\infrule[Var-ua]
    {a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p = \bot}
    {F \vdash \St{x, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{UninitializedAcess}, a, p, m}} 

\infrule[Var]
    {a(x) = l^p\{i, k, o, s\} \\ 0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p \neq \bot}
    {F \vdash \St{x, a, p, m} \to \St{v_p, a, p, m}}

\infrule[Ref]
    {a(x) = l^p}
    {F \vdash \St{\&x, a, p, m} \to \St{l^p, a, p, m}}
    
\infrule[Deref-s]
	{F \vdash \St{e,a, p, m} \to \St{e', a', p', m'}}
	{F \vdash \St{\text{*}e, a, p, m} \to \St{\text{*}e', a', p', m'}} 

\infrule[Deref-pilha-obr]
    {0 > o \ge s}
    {F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to \\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsRead}, a, p, m}}
    
\infrule[Deref-pilha-uaf]
    {0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k \neq k_p}
    {F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}} 

\infrule[Deref-pilha-ua]
    {0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p = \bot}
    {F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UninitializedAcess}, a, p, m}}

\infrule[Deref-pilha]
    {0 \leq o < s\quad p(i + o) = (v_p, k_p) \quad k = k_p \quad v_p \neq \bot}
    {F \vdash \St{\text{*}l^p\{i, k, o, s\}, a, p, m} \to \St{v_p, a, p, m}}

\infrule[Deref-memória-null]
    {i = 0}
    {F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{NullPtrDeref}, a, p, m}}

\infrule[Deref-memória-obr]
    {i \neq 0 \quad 0 > o \ge s}
    {F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{OutOfBoundsRead}, a, p, m}}
    
\infrule[Deref-memória-uaf]
    {i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k \neq k_m}
    {F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UseAfterFree}, a, p, m}}

\infrule[Deref-memória-ua]
    {i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k = k_m \quad v_m = \bot}
    {F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to\\ \St{\mathbf{panic}\;\mathbf{UninitializedAcess}, a, p, m}} 
    
\infrule[Deref-memória]
    {i \neq 0 \quad 0 \leq o < s\quad m(i + o) = (v_m, k_m) \quad k = k_m \quad v_m \neq \bot}
    {F \vdash \St{\text{*}l^m\{i, k, o, s\}, a, p, m} \to \St{v_m, a, p, m}}

\infrule[If-s]
    {F \vdash \St{e_1,a, p, m} \to \St{e_1', a', p', m'}}
    {F \vdash \St{\mathbf{if}\;(e_1)\; e_2\; \mathbf{else}\; e_3 ,a, p, m} \to\\ \St{\mathbf{if}\;(e_1')\; e_2\; \mathbf{else}\; e_3 ,a', p', m'}}
    
\infrule[If-true]
    {\mathcal{N}(v) \neq 0}
    {F \vdash \St{\mathbf{if}\;(v)\; e_1\; \mathbf{else}\; e_2 ,a, p, m} \to \St{e_1, a, p, m}} 
\infrule[If-false]
    {\mathcal{N}(v) = 0}
    {F \vdash \St{\mathbf{if}\;(v)\; e_1\; \mathbf{else}\; e_2 ,a, p, m} \to \St{e_2, a, p, m}} 
    
\infrule[While]
    {}
    {F \vdash \St{\mathbf{while}\;(e_1)\; e_2, a, p, m} \to \\ \St{\mathbf{if}\;(e_1)\; (e_2;\mathbf{while}\;(e_1)\; e_2)\; \mathbf{else}\; 0, a, p, m}} 


\infrule[CallFunc-s(j,0)]
	{F \vdash \St{e_0,a, p, m} \to \St{e_0',a', p', m'}}
	{F \vdash \St{f(e_0, e_{1..j}), a, p, m} \to \St{f(e_0', e_{1..j}), a, p, m}} 

\infrule[CallFunc-s(j,i)]
	{F \vdash \St{e_i,a, p, m} \to \St{e_i',a', p', m'}}
	{F \vdash \St{f(v_{0..i}, e_i, e_{(i + 1)..j}), a, p, m} \to\\ \St{f(v_{0..i}, e_i', e_{(i + 1)..j}), a', p', m'}}

\infrule[CallFunc]
	{F(f) = \St{[\overline{x_i}], e}}
	{F \vdash \St{f(\overline{v_i}), a, p, m} \to \\\St{\mathbf{Fpop}\,\{\ \overline{\mathbf{let}\;x_i[1]; x_i := v_i;} e\}, (STOP : a, g), \mathbf{func} : p, m}} 

	
\infrule[Fpop-s]
	{F \vdash \St{e,a, p, m} \to \St{e',a', p', m'}}
	{F \vdash \St{\mathbf{Fpop}\;e,a, p, m} \to \St{\mathbf{Fpop}\;e',a', p', m'}} 

\infrule[Fpop-s]
	{\mathbf{pop}_{func}(p) = p'}
	{F \vdash \St{\mathbf{Fpop}\; v, (h : a, g), p, m} \to \St{v, (a, g), p', m}} 

}

%	3.4 Error detection
\section{Detecção de Erros}

% In order to detect these kinds of errors, the metadata attached to the pointers 
% needs to uphold certain invariants.$\bullet$ If the offset $o$ of a pointer is 
% bellow 0 or equal or greater than its size $s$ ($0 > o \ge s$), then it results 
% in a \textit{Out of Bounds Read}, such as in (VAR-OBR), which is a Spacial Safety bug.
% $\bullet$ If it is within bounds, but the key $k$ in the pointer does not match 
% the lock $k'$ at the position ($k \neq k'$), then it results in a \textit{Use After Free}, such as in (VAR-UAF), which is a Temporal Safety bug. $\bullet$ With all that, if the value at position is $\bot$, then it results in a \textit{Uninitialized Access}, 
% which is a Initialization safety bug.

% There are a few other errors in the language that were omitted for space, 
% but all of them follow the same principle. This way of approaching errors 
% ends up defining them by the upholding of these invariants. 
% A \textit{Use After Free} error is defined by an access where $k \neq k'$,
% and a case of \textit{Use After Free} only indicates that $k \neq k'$,
% showing that $\mathbf{UseAfterFree} \leftrightarrow k \neq k'$.

