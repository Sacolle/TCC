% 1. Introdução
\chapter{Introdução}

A linguagem de programação C \cite{CLANG} é a fundação de programação de sistemas. Até a incorporação de Rust no começo de 2024 \cite{RUSTFORLINUX}, C era a única linguagem do \emph{kernel} do Linux. Mesmo com essa grande importância, C é extremamente vulnerável a falhas de memória, com muito poucas restrições do compilador a fim de evitar essas falhas. Essa liberdade é, em parte, o ponto da linguagem C, que serve como uma simples fachada genérica sobre o Assembly da máquina. Porém, C faz parte de muitas partes críticas de infraestrutura para que a validação de novos sistemas não seja feita de forma rigorosa. 

No começo do milênio, Cyclone \cite{CYCLONE1} começou a popularização de linguagens de programação de baixo nível com sistema de memória seguro sem o uso amplo de \emph{Garbage Collectors} (GC). Essa tendencia foi seguida pelo projeto da Microsoft, CCured \cite{CCURED}, alguns anos depois. Essas duas linguagens partiram da sintaxe de C e adicionaram elementos de segurança de memória, com o fim de facilitar o porte de programas C para essa versão com mais ferramentas de segurança.

No começo dos 2010s, o projeto Rust \cite{RUSTBOOK} surgiu com novas propostas de solução de memória, quebrando o paradigma da similaridade com C. Essas novas técnicas, principalmente o \emph{Borrow Checker}, apresentaram oportunidades de segurança de memória sem perda de desempenho, coisa que os seus predecessores não conseguiram atingir. A partir disso, novos sistemas foram emergindo, partindo de novas tecnologias como LLVM \cite{LLVM} que simplificam o processo de desenvolvimento de linguagens de programação, cada uma com uma proposta nova de como evitar falhas de memória.

O ambiente rico em soluções de segurança de memória evoca o pensamento: quais são corretas? Quais são efetivas? Quais tornam a linguagem restrita? Para linguagens que pretendem ser posicionadas em caminhos críticos de infraestrutura, como Rust, a demonstração de sua corretude é fundamental para a sua adoção e a possibilidade de se concorrer com o atual déspota de sistemas de baixo nível, C.

\section{Trabalhos Relacionados}


Muitos dos trabalhos de prova de solução de memória focam na linguagem Rust e seu \emph{Borrow Checker}. O projeto RustBelt \cite{RUSTBELT}, fundado em 2017, tinha como meta provar a corretude do \emph{Borrow Checker} de Rust e o seu sistema de tipos. Para isso, foi utilizado uma versão de Rust formulada em \emph{continuation-passing style} para gerar os sistemas de prova. O sistema de detecção de falhas deste inspirou o sistema de $PCL_{back}$ (\emph{back-end Porcelain}). Uma alternativa a esse projeto foi \emph{Sound Borrow-Checking for Rust via Symbolic Semantics} \cite{RUSTSYMBOLIC}. Nele, realiza-se um método de prova similar ao alvejado a neste trabalho, de realizar provas sobre a compilação de um programa para uma linguagem base. A definição de $PCL_{front}$ foi baseada no algoritmo Polonius \cite{Stjerna1684081}, entretanto, outras formulações desses foram construídas e provadas corretas, como \emph{A Lightweight Formalism for Reference Lifetimes and Borrowing in Rust} \cite{RUSTFORMALISM}. 

%	1.3 Objetivos
\section{Objetivos}

O objetivo desse projeto é explorar as falhas de memória que existem em sistemas e com isso construir uma linguagem alvo de compilação, $PCL_{back}$, que detecte falhas essas memória. Para provar a utilidade dessa estratégia, também é proposto o desenvolvimento de uma linguagem que compilará para a linguagem base, $PCL_{front}$ (\emph{front-end Porcelain}). Ela implementará um sistema de \emph{Borrow Checker} com o fim de, através de compilação a $PCL_{back}$ a implementação deste possa ser provada correta.

Esse trabalho contribui para a discussão de falhas de memória e serve como um meio flexível de provar outras estratégias mais inconvencionais em um campo mais neutro. Dessa forma, ele permite estratégias mais \emph{bottom-up} no desenvolvimento de linguagens, em que primeiro decide-se e prova-se uma estratégia de memória para depois desenvolver a linguagem que a envolve.

%	1.4 Organização
\section{Organização}

O restante deste trabalho é classificado da seguinte forma. No capítulo \ref{chap2} são elaborados conceitos básicos para o entendimento do projeto. Isso inclui uma explicação simples de semântica operacional e sistema de tipos junto de uma elaboração sobre falhas de memória, significado, tipos e soluções propostas ao longo dos anos. No capítulo \ref{chap3} é introduzido $PCL_{back}$, a linguagem alvo de compilação do projeto. Para isso, elabora-se sobre as suas estruturas de avaliação, regras e correspondência com os erros do capítulo \ref{chap2}. Com esses dois capítulos, define-se a base do projeto. A partir desse ponto, passa-se a discorrer um caso de uso do sistema. O capítulo \ref{chap4} discorre sobre os conceitos necessários para o desenvolvimento da linguagem $PCL_{front}$, explicada no capítulo \ref{chap5}. O projeto é concluído no capítulo \ref{chap7}.
