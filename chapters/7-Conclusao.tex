% 7. Conclusão
\chapter{Conclusão}
\label{chap7}

Este projeto se iniciou visando definir um sistema para provar métodos de segurança de memória. Esse desenvolvimento estendeu-se até a definição da linguagem de \emph{front-end}, $PCL_{front}$. Com ela, pode-se definir uma semântica que evita falhas de \emph{Use-After-Free} utilizando um sistema de \emph{Borrow Checker} com o algoritmo Polonius. Esse sistema se inspirou também em outros métodos para adequá-lo melhor ao contexto de implementação.

A construção de $PCL_{back}$ é expressiva suficiente para modelar todas as falhas de memória com claridade. Durante este texto, foram usados alguns exemplos dessa expressividade (\ref{lst:pclback:spacial}), levando em conta a ocorrência dessas falhas em C. Mais exemplos desses paralelos foram construídos entre os erros de C e $PCL_{back}$, mas foram omitidos por espaço. Uma série deles existe na publicação Erros de Memória e Porcelain no blog do autor\footnote{\url{https://sacolle.github.io/blog/posts/porcelain-emulando-os-erros-de-memoria-de-c/}}, que foi desenvolvido paralelamente a este trabalho.

Este projeto serve como um estudo sobre falhas de memória, suas definições, problemas e soluções. Ao construir as linguagens $PCL_{back}$ e $PCL_{front}$ pode-se se aproximar mais desses conceitos, aplicando eles de forma prática e direta. Nesse processo, almejou-se construir novas técnicas e reformular o que é uma falha de memória. A relevância deste projeto é essa visão mais micro dessas falhas, as suas minúcias e desafios quando as tenta solucionar.

% falar aqui da do sistema em haskell
\section{Resultados Obtidos}

A AST (árvore sintática abstrata) das linguagens, e as suas respectivas avaliações, foram implementadas em Haskell. A sintaxe da linguagem se provou muito próxima da anotação matemática, permitindo rápida iteração entre mudança de anotação e mudança de código e vice e versa. Para $PCL_{back}$ foi também desenvolvido um \emph{lexer} e um \emph{parser}, também em Haskell, que auxiliaram muito na prototipação da linguagem e na formulação de exemplos. A adição de declarações globais surgiram desse processo de iteração, em que se observou que seria necessário para demonstrar as falhas associadas a estruturas globais de alocação de memória. A formatação das linguagens também as posiciona bem caso o projeto progredir para o uso de um sistema de provas formais, como Coq \cite{COQ} ou Lean \cite{LEAN4}, que usam uma notação funcional similar a Haskell.
% 	7.1 Limitações
\section{Limitações}

Devido às limitações de escopo deste projeto, não foi possível atingir todos os almejos deste projeto. Mesmo com $PCL_{front}$ tendo sua funcionalidade reduzida para caber no escopo, não foi possível chegar no estágio de validação dessa linguagem. Precisa-se, ainda, realizar testes e validar o modelo de \emph{alias} da linguagem a fim de validar que não existem erros lógicos na formação deste. Por consequência, não se conseguiu progredir para a etapa de prova do trabalho, em que se tentaria provar formalmente a segurança de memória de $PCL_{front}$ quanto erros de \emph{Use-After-Free}.

A linguagem $PCL_{back}$, por sua vez, tem sua expressividade limitada devido a certas decisões que facilitaram a sua implementação. A maior delas foi como foram implementadas alocações com $\KW{malloc}$ e liberações com o $\KW{free}$. O fato de $\KW{free}$ necessitar da quantidade de espaços a serem liberados gera padrões que não possuem correspondentes em C. Isso fez com que as definições de erros temporais que corrompem a função \lstinline[language=C]|free| em C sejam mais arbitrárias que o desejado na sua reprodução em $PCL_{back}$. Além disso, a linguagem não possui nenhuma proteção contra acessos fora dos limites de estruturas dentro de \emph{buffers}. Caso se esteja operando sobre estruturas em listas, pode-se não intencionalmente sobrescrever membros de uma estrutura da lista ao acessar outro. Outra limitação que estende dessa é que $PCL_{back}$ não é tipado. Esse fato simplifica a compilação a ele, mas omite certas informações para captura de certas falhas mais veladas. Além disso, $PCL_{back}$ depende da semântica da linguagem para definir a compatibilidade entre tipos, que pode ser prejudicial na hora de realizar as provas estruturais.

% 	7.2 Future Work
\section{Trabalhos Futuros}

O futuro deste trabalho está bem traçado, complementar e validar $PCL_{back}$, possivelmente reformulando alguns conceitos, como a ampla mutabilidade dos \emph{alias}, e depois provar que o sistema previne falhas de \emph{Use-After-Free}. É de interesse também gerar uma prova que a compilação para $PCL_{back}$ é correta. Não é fora do escopo talvez gerar uma linguagem de \emph{front-end} que implemente uma solução de memória mais simples para testar o processo e fazer modificações necessárias nele, caso a prova do sistema de $PCL_{front}$ se demonstre muito penosa.

Uma aspiração grandiosa deste trabalho é fazer várias linguagens de \emph{front-end}, refinando o trabalho todo no processo de prová-las através da compilação para $PCL_{back}$. Qualquer progresso no trabalho será publicado no blog do Autor\footnote{\url{https://sacolle.github.io/blog/}} , que com sorte será periodicamente. 