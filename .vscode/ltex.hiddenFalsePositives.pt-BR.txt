{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QUm exemplo dessa falha é um , leitura de um para uma posição anterior ao começo.\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QPodendo ocorrer na pilha ou na memória, para o final ou para o começo do , devido a um cálculo incorreto de tamanho do ou de índice de acesso.\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QAssim, a cada acesso, verifica-se se este está dentro dos limites do , se não estiver, gera uma terminação controlada.\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QLinguagens como Rust, Zig e Go se utilizam desse mecanismo, entretanto sob o nome de .\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QEla engloba casos de e , assim como erros associados a função free de C. O caso de , é uma descrição de todo e qualquer acesso a quando o objeto que se encontrava no local já havia sido liberado.\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QQuando ocorre na pilha pode ser descrito pelo nome mais específico , sendo o acesso a um endereço na pilha que já foi liberado pelo desempilhamento desta.\\E$"}
{"rule":"A_QUANDO","sentence":"^\\QEla engloba casos de e , assim como erros associados a função free de C. O caso de , é uma descrição de todo e qualquer acesso a quando o objeto que se encontrava no local já havia sido liberado.\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QUm exemplo dessa falha é o seguinte .\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QOutro exemplo, agora de , retorna um alocado na pilha.\\E$"}
{"rule":"QUE_É-SÃO_NC-ADJ_COMO-POR","sentence":"^\\QFundamentalmente, a classe lida com leitura e escrita a regiões de memória não estáticas, ou seja, alocações na pilha, que são removidas no fim do escopo; e alocações na memória, que podem ser arbitrariamente de-alocados.\\E$"}
{"rule":"COMMA_PARENTHESIS_WHITESPACE","sentence":"^\\QEm troca, o programa sofre breves pausa periódicas (GC ) na execução e a gerência do GC custa processamento que certos ambientes não tem disponível para gastar.\\E$"}
{"rule":"FRAGMENT_TWO_ARTICLES","sentence":"^\\QEsse mecanismo detecta e retorna automaticamente memória alocada e não mais utilizada para o OS.\\E$"}
{"rule":"PARENTESESE_AND_QUOTES_SPACING","sentence":"^\\QUm componente importante dessa classe são as falhas associadas a liberação de memória, principalmente tratando-se da função da de C. Falhas como (chamar para um endereço liberado), (chamar em um ponteiro que não aponta para a ), (chamar com um ponteiro que não inicia a lista) e (chamar uma função de liberação de memória para memória alocada com outro sistema) ocorrem devido a uma ação que corrompe a estrutura de dados usadas para gerir alocação.\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QA seção se encontra aqui, pois há a interação que passar o ponteiro nulo para a função gera uma falha , visto que o endereço do nulo tende a ser 0, que não é um valor na do programa.\\E$"}
{"rule":"FRAGMENT_TWO_PREPOSITIONS","sentence":"^\\QUm exemplo dessa falha é o acesso a em um caminho que não incializa ela, que vir ler valores arbitrários na .\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QUm exemplo dessa falha é o acesso a em um caminho que não inicializa ela, que vir ler valores arbitrários na .\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QEssa classe de erros é interessante pois é nela em que há a maior intersecção com .\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QEssa classe de erros é interessante, pois é nela em que há a maior intersecção com .\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QEla é definida por sintaxe e semântica operacional .\\E$"}
{"rule":"CRASE_CONFUSION_2","sentence":"^\\QEssa é uma razão bem circular, as falhas são comuns em C porque este permite acesso brando a memória, assim elas são descritas e a linguagem que melhor reproduz elas é C, pois tem acesso a memória.\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QO layout de memória de um programa em C tem vários componentes: o segmento de texto, que contém o programa em si; a seção de dados, que guarda elementos globais, assim como literais e outros elementos escritos no código; a pilha e a .\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QA dinâmica entre alocações manuais, aquelas que acontecem na , e alocações estáticas, aquelas que acontecem na pilha, é um componente importante na reprodução de de memória.\\E$"}
{"rule":"FRAGMENT_TWO_PREPOSITIONS","sentence":"^\\QA dinâmica entre alocações manuais, aquelas que acontecem na , e alocações estáticas, aquelas que acontecem na pilha, é um componente importante na reprodução de de memória.\\E$"}
{"rule":"COLOCAÇÃO_ADVÉRBIO","sentence":"^\\QFalhas na tendem a ser mais difíceis de encontrar e lidar, pois o processo de requisitar memória e liberá-la manualmente tende a aumentar a superfície de falhas.\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QCom o intuito de modelar essa dinâmica, a memória em \\E(?:Dummy|Ina|Jimmy-|Dummy-|Maniquí-|Maniquíes-)[0-9]+\\Q usa dois ambientes disjuntos, \\E(?:Dummy|Ina|Jimmy-|Dummy-|Maniquí-|Maniquíes-)[0-9]+\\Q para modelar a pilha e \\E(?:Dummy|Ina|Jimmy-|Dummy-|Maniquí-|Maniquíes-)[0-9]+\\Q para modelar a , que, com o intuito de diminuir os estrangerismos, poderá ser referida como memória a partir deste ponto.\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QCom o intuito de modelar essa dinâmica, a memória em \\E(?:Dummy|Ina|Jimmy-|Dummy-|Maniquí-|Maniquíes-)[0-9]+\\Q usa dois ambientes disjuntos, \\E(?:Dummy|Ina|Jimmy-|Dummy-|Maniquí-|Maniquíes-)[0-9]+\\Q para modelar a pilha e \\E(?:Dummy|Ina|Jimmy-|Dummy-|Maniquí-|Maniquíes-)[0-9]+\\Q para modelar a , que, com o intuito de diminuir os estrangeirismos, poderá ser referida como memória a partir deste ponto.\\E$"}
{"rule":"CRASE_CONFUSION_2","sentence":"^\\QEssa é uma razão bem circular, as falhas são comuns em C porque este permite acesso brando a memória e assim elas são descritas, porém a linguagem que melhor reproduz elas é C, pois tem acesso a memória.\\E$"}
{"rule":"CRASE_CONFUSION_2","sentence":"^\\QEssa é uma razão bem circular, as falhas são comuns em C porque este permite acesso brando a memória e assim elas são descritas; a linguagem que melhor reproduz elas é C, pois tem acesso a memória.\\E$"}
{"rule":"SPACE_BEFORE_PUNCTUATION2","sentence":"^\\QAssim como o acesso na pilha, essa operação pode ser vista como uma simples indexação a um .\\E$"}
{"rule":"TODOS_FOLLOWED_BY_NOUN_PLURAL","sentence":"^\\QAs globais do programa são declaradas todas declaradas juntas no começo do programa\\E$"}
{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qavalia para o endereço alocado na pilha \\E(?:Dummy|Ina|Jimmy-|Dummy-|Maniquí-|Maniquíes-)[0-9]+\\Q.\\E$"}
{"rule":"GENERAL_NUMBER_AGREEMENT_ERRORS","sentence":"^\\QAo invés de utilizar um GC para abstrair o acesso à memória do programador, Rust se utiliza de uma série de regras para checar e gerir, em tempo de compilação, os acessos à memória, evitando erros como \\E(?:Dummy|Ina|Jimmy-|Dummy-|Maniquí-|Maniquíes-)[0-9]+\\Q, \\E(?:Dummy|Ina|Jimmy-|Dummy-|Maniquí-|Maniquíes-)[0-9]+\\Q, etc. O mecanismo dentro da linguagem que faz essa validação é o Borrow Checker.\\E$"}
{"rule":"COLOCAÇÃO_ADVÉRBIO","sentence":"^\\QFalhas na \\E(?:Dummy|Ina|Jimmy-|Dummy-|Maniquí-|Maniquíes-)[0-9]+\\Q tendem a ser mais difíceis de encontrar e lidar, pois o processo de requisitar memória e liberá-la manualmente tende a aumentar a superfície de falhas.\\E$"}
